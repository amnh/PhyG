\documentclass[11pt]{article}
\usepackage{longtable}
\usepackage{color}
\usepackage{tabu}
\usepackage{setspace}
\usepackage{pdflscape}
\usepackage{graphicx}
%\usepackage{subfigure}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{natbib}
\usepackage{fullpage}
%\bibliographystyle{plain}
\bibliographystyle{cbe}
\usepackage{algorithmic}
\usepackage[vlined,ruled]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true, linkcolor=blue, citecolor=DarkOrchid, urlcolor=TealBlue ]{hyperref}
\usepackage[nottoc,numbib]{tocbibind}

\let \oriAlgorithm=\algorithm%
\renewcommand{\algorithm}[2]{%
	\oriAlgorithm%
	\SetAlgoLined%
	\DontPrintSemicolon%
	\SetKwComment{Comment}{$\triangleright\ $}{}%
	\TitleOfAlgo{ #1 }%
	\caption{ #2 }%
}%
\newcommand*{\Set}[2]{ #1 $\gets$ #2 \;}
\newcommand*{\SetC}[3]{ #1 $\gets$ #2 \Comment*[r]{#3}}
\newcommand*{\ForC}[3]{\For(\Comment*[f]{#2}){#1}{#3}}

\begin{document}
	%\firstpage{1}
	
	\title{PhylogeneticGraph\\Program Documentation\\Version 0.1}
	%\subtitle{Program Documentation\\Version 0.1}
	\author{Ward C. Wheeler\\
		Division of Invertebrate Zoology,\\ American Museum of Natural History,\\ 200 Central Park West, New York, NY, 10024, USA;\\wheeler@amnh.org}
	
	
	\maketitle
%	\begin{center}
%		Running Title: {PhyGraph Version 0.1}
%	\end{center}
	\newpage
	
	\tableofcontents
	\newpage
	\section{Introduction}
	This document contains descriptions of algorithms, procedures, data structures and other aspects of the 
	source code documentation for the program PhylogeneticGraph (\texttt{PhyG}).  
	
	 \texttt{PhyG} is a sucessor program to \texttt{POY} \citep{POY2,POY3,POY4,Varonetal2010,POY5, Wheeleretal2015} \url{https://github.com/wardwheeler/POY5}, 
	 although a ``complete'' Haskell rewrite, optimized C (and even some assembler) was ported over from POY for pairwise alignment of small alphabet (<8)
	 sequences.  These functions are access via the Haskell FFI.
	
	
	
	\section{Overview of Code base}
	Source code structure.
	
	\section{Character reorganization and optimizing}
		Input data are passed through several fuincionts to:
		\begin{itemize}
			\item{Rename taxa}
			\item{Exclude taxa}
			\item{Add missing data for taxa not present in all input files}
			\item{Check that input taxa and any input graphs contain teh same leaf set}
			\item{Data a reblocked if specified}
			\item{Static (Non-additive, additive, and matrix) characters are reorganized so that
				each class is put in a single (extensive) character (one for each type) type for each block.}
			\item{Non-additive characters are `bit-packed' into new characters with state numbers $=$2, $\leq$
				4, $\leq$5, $\leq$8, $\leq$64, and $>$ 64. Invariant charcaters are filtered out.}
			 
		\end{itemize}
		\subsection{Character weights}
		Static characters (Non-additive, additive, and matrix) with integer weights are reorganized
		by repeating th echaracter the number of times of its weight.  This is to avoid alot of 
		unnecessary ($\times 1$) operations.  Non-integer weight characters are not reorganized or
		bit packed.
		
		\subsection{BitPacking}
		Non-additive characters, either from input or static approximation recoding, are initially 
		encoded as little-endian bit-vectors.  These are flexible, with unbounded (more or less)state numbers.
		They are also inefficient in space nad optimization compared with native types such as Word64. 
		
		An additional level of inefficiency comes from encoding characters with lower numbers of states in type (e.g. word64) with a single bit for each state.  As a result, non-additive characters are recoded according to their 
		number os states into 5 new character types (in Types.hs): Packed2, Packed4, Packed5, Packed8, and Packed64. 
		
		Characters with $>$ 64 states remain (although a new character is created) as bit-vectors.  Characters with 
		2, 3-4, 5, and 6-8 states are ``packed'' into 64 bit Word64 with 32, 16, 12, and 8 characters per word respectively. Characters with 9-64 states are encoded as a single Word64. These are concatenated into a Vector and stored in characterData as ``packedNonAddPrelim'' and ``packedNonAddFinal''.
		
		Non-additive charterers are first separated into groups of like-state number, then appropriate ercodign
		and packing are applied.  One important point is that states may be non-sequential (ie 3 and 23), yet
		still binary (after accounting for ``missing'' = all bits On).  THe are identifiued and recoded as seqeuntial states (bits 0,1,2..).
		
		Simultaneous 2-median and 3-median (post-order and pre-order) optimization is performed via the methods described in \cite{WhiteandHolland2011} and \cite{goloboff2002} modified for 64-bit words and alternate state numbers (basically mask and shit numbers).  These methods, documented and undocumented likely originate with D. E. Knuth ina general sense, and \cite{Farris1988} in phylogenetic software.
		
		The module Input.BitPack.hs contains the functions and constants (e.g. masks) to deal 
		with bit-packed characters.
		
	\section {Command Parsing}
	
	\section{Post-Order Graph Traversal}
		\subsection{Trees}
		A decorated Graph (tree) is created for each character for each block for the graph.  For exact characters, where no addition traversals are required, 
		the specified or default
		outgroup sets the direction of the graph.  For non-exact (e.g. sequence) characters the best traversal rooting is stored for each character in each block
		although the cost of the graph is recalculated based on the best traversal (over all edges in the graph), the preliminary (post-order) states are not propagated back
		to the decorated graph (third field of phylogenetic graph).  After the pre-order pass, the final states are propagated back.
		Vertices are not renumbered during the rerooting process, so indices remain unchanged.
		
			Preliminary states (post-order) are determined for exact and non-exact characters as in \cite{Wheeler2012}.
	
	\section{Pre-Order Graph Traversal}
		\subsection{Trees}
		Final state assignments of root vertices are set to the preliminary, post-order state.
		Final  states are propagated back to the decorated graph (third field of phylogenetic graph).
		Vertices are not renumbered during the rerooting process, so indices remain unchanged.
		
		Final states (pre-order) are determined for exact and non-exact characters as in \cite{Wheeler2012}.  Currently final states for 
		non-exact characters (e.g. sequence) are set as the median between the gapped preliminary state of the vertex and the final state of its parent
		(for a tree), `extra' gaps in preliminary state are propagated to the gaped left and right descendant sequences, left, right, and parent final sequences
		should now line up and a 3-median can be calculated.
		

	\section{Adding New Character Types}
		Current character types include Additive, Non-Additive, Matrix, Slim Sequences, Wide Sequences, and Huge Sequences.  
		Functions that branch on character types need to be updates and are found in:
		\begin{itemize}
			 \item{GraphOptimization.Medians.hs}
			 	\begin{itemize}
			 		\item{Median2Single}
					\item{Median2SingleStaticIA}
					\item{Union2Single}
					\item{GetPrealignedUnion}
					\item{getPreAligned2Median}
					\item{median2SingleNonExact}
			 	\end{itemize}
			 \item{GraphOptimization.PreOrderFunctions.hs}
			 	\begin{itemize}
			 		\item{updateCharacter}
			 		\item{getCharacterDistFinal}
			 		\item{setFinal}
			 		\item{setPrelimToFinalCharacterData}
			 	\end{itemize}
		 
			 \item{Commands.Transform.hs}
				\begin{itemize}
				\item{transformCharacter}
			\end{itemize}
			 \item{Commands.CommandExecution.hs}
				\begin{itemize}
				\item{makeCharLine}
				\item{getCharacterLength}
				\item{getCharCodeInfo}
				\end{itemize}
			 \item{Types.Types.hs}
				 \begin{itemize}
				 	\item{CharType}
				 	\item{nonExactCharacterTypes}
				 	\item{exactCharacterTypes}
				 	\item{prealignedCharacterTypes}
				 	\item{CharacterData}
				 	\item{emptyCharacter}
				 \end{itemize}
			 \item{Utilities.Utilities.hs}
				\begin{itemize}
					\item{getCharacterInsertCost}
					\item{makeBlockCharacterString}
					\item{pairList2Fasta}
					\item{splitBlockCharacters}
					\item{getNumberNonExactCharacters}
				\end{itemize}
			 \item{Utilities.ThreeWayfunctions.hs}
				\begin{itemize}
					\item{threeMedianFinal}
				\end{itemize}
			 \item{Support.Support.hs}
				\begin{itemize}
					\item{subSampleStatic}
					\item{makeSampledPairVect}
				\end{itemize}
			 \item{Input.Reorganize.hs}
			 \begin{itemize}
			 	\item{filterConst}
			 	\item{getVariableChars}
			 	\item{assignNewField}
			 	\item{organizeBlockData'}
			 \end{itemize}
		 	  \item{Input.FastAC.hs}
		 	 \begin{itemize}
		 	 	\item{Functions for sequence data processing on input}
		 	 \end{itemize}
		 	 \item{Input.DataTransformation.hs}
		 	 \begin{itemize}
		 	 	\item{These are for input--so not used by static approx}
		 	 	\item{getMissingValue}
		 	 	\item{getGeneralSequenceChar}
		 	 	\item{getQualitativeCharacters--potentially depending on character features}
		 	 	\item{createLeafCharacter}
		 	 	\item{missingAligned}
		 	 \end{itemize}
		 	 
			 \item{Functions with ``== NonAdd'' etc will need extra cases for any new character type}
	\end{itemize}
	\subsection{Execution in Parallel}
	By default the program will execute multi-threaded based on the number processors available.  By specifying the options `+RTS -NX -RTS' where `X' is the number of processors offered to the program. These are specified after the program as in (for 4 parallel threads):\\
	\\
	PhyGraph +RTS -N4 -RTS other options...  \\
	
	Parallel code options are set using a parmap-type strategy throughout the code.  THis ujsually speciifed by myParListChunkRDS from the PArallelUtilities module in PhyloLibs The basic definitions of this functionality are found in ParallelUtilities.hs
	
	\section*{Acknowledgments}
	The author would like to thank DARPA SIMPLEX N66001-15-C-4039, the  Robert J. Kleberg Jr. and Helen C. Kleberg foundation grant ``Mechanistic Analyses of Pancreatic Cancer Evolution'', and the American Museum of Natural History for financial support.  
	
	\newpage
	%\bibliography{big-refs-3.bib}
	%\bibliography{/users/ward/Dropbox/Work_stuff/manus/big-refs-3.bib}
	\bibliography{/home/ward/Dropbox/Work_stuff/manus/big-refs-3.bib}
\end{document}