%---------------------------------------------
%build
%---------------------------------------------
\subsection{Build}
	\subsubsection{Syntax}
		\texttt{build(arg0, arg1:option, ...)}
	
	\begin{phygdescription}
		{Builds initial graphs. Most options (with the exception of the $O(n^3)$ distance based 
		\texttt{dWag} option) 	are $O(n^2)$. Builds may be based on character methods or those 
		based on distance methods. Distance methods are considerably faster (lower constant 
		factor), but approximate in terms of character-based methods. Refinement (branch swapping) 
		can be specified within the command for distance builds. Refinement for character-based 
		Wagner builds occurs after the \texttt{build} process through \texttt{swap} and other refinement 
		commands. Given the large time burden, distance refinement is usually not time effective 
		\citep{Wheeler2021}.}
	\end{phygdescription}
		
	\subsubsection{Arguments}

	\begin{description}
		\item [atRandom] When option \texttt{block} is specified, returns $n$ display trees specified by 
		\texttt{displayTrees[:n]} where trees are produced by resolving network nodes uniformly at random. 
		This is in opposition to the \texttt{first} option, which takes the ``first'' $n$ display trees resolved 
		in arbitrary, but consistent, order.

		\item [best:n] Applies only to rdWag. Specifies the number of trees retained after rdWag builds, 
		selecting the best trees in terms of distance cost. The options can be used to reduce
		the number of trees retained for refinement or returned for further analysis. 

		\item[block] Performs independent builds for each ``block'' of data. Builds are performed according 
		to the other options (e.g. \texttt{character, replicates:n}). The resulting trees are reconciled using the 
		\texttt{eun} or \texttt{cun} commands. The reconciled graph is resolved into display trees via the 
		\texttt{displayTrees}, \texttt{first}, and \texttt{atRandom} options. This option is especially useful 
		for softwired network search. If the number of display trees is not specified, up to $2^{63}$ may be 
		returned.

		\item [character] Performs random addition sequence Wagner \citep{Farris1970} builds ($O(n^2)$) 
		for tree construction. If the graphtype is softwired or hardwired the resulting trees are rediagnosed 
		as softwired graphs.
		
		\item [cun] Reconciles block trees into a Cluster-Union-Network \citep{Baroni2005} before resolution 
		into display trees via the \texttt{displayTrees}, \texttt{first}, 	and \texttt{atRandom} options.

		\item [displayTrees:[n]] When option \texttt{block} is specified, returns $n$ display trees specified 
		by the optional argument If the number of display trees is not specified, up to $2^{63}$ may be returned.

		\item [distance] Causes a pairwise distance matrix to be calculated ($O(n^2)$) and used as a basis 
		for distance tree construction.
		
		\item [dWag] Performs distance Wagner build as in \citep{Farris1972} choosing the `best' taxon to 
		add at each step, yielding a single tree. Time complexity of $O(n^3)$.
		
		\item [eun] Reconciles block trees into a Edge-Union-Network \citep{MiyagiandWheeler2019, 
		Wheeler2022} before resolution into display trees via the \texttt{displayTrees}, \texttt{first}, and 
		\texttt{atRandom} options.

		\item [graph] When \texttt{block} option is specified, returns the reconciled graph as specified by 
		\texttt{eun} or \texttt{cun}. The graph may be altered to ensure that it is a ``phylogenetic'' graph 
		sensu \cite{Moretetal2005}.
		
		\item [nj] Performs Neighbor-Joining distance build \citep{Saitou1987}, yielding a single tree. 
		Time complexity of $O(n^3)$.

		\item [none] No refinement (OTU,SPR,TBR) is performed after distance builds.
	
		\item [otu] Specifies that OTU refinement \citep{Wheeler2021} is performed after distance builds.	
		
		\item [replicates:n] Applies to \texttt{rdWag} and \texttt{character}. Specifies the number of 
		random addition sequences performed. 
		
		\item [rdWag] Performs randoms addition sequence distance Wagner builds, yielding a multiple 
		trees determined by argument \texttt{replicates:m}. Time complexity of $O(m \times n^2)$.

		\item [spr] Specifies that SPR refinement \citep{Dayhoff1969} is performed after distance builds.

		\item [tbr] Specifies that TBR refinement \citep{Farris1988, swofford1990a} is performed after 
		distance builds.
		
		\item [wpgma] Performs Weighted Pair Group Method with Arithmetic Mean distance build 
		\citep{SokalandMichener1958}, yielding a single tree. Time complexity of $O(n^2)$.
	
	\end{description}		

	\subsubsection{Defaults}
		\texttt{build(character, replicates:10)}


	\begin{example}
	
		\item{\texttt{build(distance, dWag, nj, wpgma)} \\ 
		Builds a single `best' addition sequence distance Wagner build, 
		a Neighbor-Joining tree, and a WPGMA tree.}
		
		\item{\texttt{build(distance, rdWag, replicates:1000, best:10)}\\
		Builds 1000 random addition sequence distance Wagner builds and returns 
		10 of lowest distance cost.}
	
		\item{\texttt{build(distance, rdWag, WPGMA, replicates:100, best:10, OTU)}\\
		Builds 100 random addition sequence distance Wagner builds, a WPGMA tree, 
		performs OTU swapping on the WPGMA and 10 of the lowest cost random addition 
		sequence Wagner trees. 
		10 of lowest distance cost.}
	
		\item{\texttt{build(replicates:100)} \\
		Builds 100 random addition sequence character Wagner builds.}

	\end{example}

%---------------------------------------------
%fuse
%---------------------------------------------
\subsection{Fuse}
	\subsubsection{Syntax}
		\texttt{fuse(option, option, ...)}
		
	\begin{phygdescription}
		{Operates on a collection of graphs preforming reciprocal graph recombination between pairs of 
		graphs \citep{moilanen1999, moilanen2001, goloboff1999}. Non-identical subgraphs with identical 
		leaf sets are exchanged between graphs and the results evaluated. This can be used in concert 
		with other options to perform a Genetic Algorithm refinement \citep{Holland1975}. The behavior of 
		\texttt{fuse} can be modified by the use options specifying SPR and TBR-like rearrangement of the 
		combination process.}
	\end{phygdescription}
	
	\subsubsection{Arguments}
	\begin{description}
		\item [best] Returns best graphs found during fuse operations.		
		
		\item [keep:n] Limits the number of returned graphs to $n$. 
		
		\item [nni] Causes the exchanged subgraphs to be tried at their initial positions as well as the 
		two adjacent edges.
		
		\item [once] Performs a single round of fusing on input graphs and returns the resulting graphs. 
		Alternatively (and by default) fusing continues recursively until no new graphs are found.
		
		\item [spr[:n]] Causes the exchanged subgraphs to be tried at multiple positions (up to optional 
		$n$ edges aware from their initial positions).
		
		\item [tbr[:n]] Causes the exchanged subgraphs to be tried at multiple positions (up to optional 
		$n$ edges aware from their initial positions) and with TBR-style rerooting of the exchanged components.
		
		\item [unique] Returns all unique graphs found during fuse operations.	
	\end{description}	
	
	\subsubsection{Defaults}
		\texttt{fuse()} Keeps all best graphs found, continues fusing until no new graphs are found. No branch 
		swapping style rearrangements are performed.
	
	\begin{example}
	
		\item{\texttt{fuse(best, once)}\\Fuses input graphs and returns best graphs after a single round of 
		fusing.}
		
		\item{\texttt{fuse(tbr, keep:10)} \\Fuses input graphs and preforms TBR-style replacement and 
		rerooting of pruned components returning up to 10 best cost graphs.}
		
	\end{example}

%---------------------------------------------
%read
%---------------------------------------------	
\subsection{Read}
	\subsubsection{Syntax}
		\texttt{read(option:"filename", option:"filename", ...)}
			
	\begin{phygdescription}
		{Imports file-based information. \texttt{read} commands must contain an input file. Supported 
		formats include Dot, Enewick, FASTA, FASTC, Fenewick, Hennig86, Newick, and \hl{XXX...}. 
		Filenames must be included in quotes and, if multiple filenames are specified, separated by 
		commas. Filenames must include the appropriate suffix (e.g. .fas, .ss\, .mat). Options prepended 
		to the filename with a colon (`:') modify the processing of the input file. If no options 
		are specified, the program will attempt to recognize the file type and parse appropriately. Wildcard 
		characters (`*', `?') can be used to specify multiple files.}
	\end{phygdescription}

	\subsubsection{Arguments}
	
	\begin{description}
		\item [aminoacid:] File contents are parsed as IUPAC coded amino acid data in fasta 
		\citep{PearsonandLipman1988} format.

		\item [block:] Specifies that the file contains block information. Each line contains 
		the new block name followed by names of input files to be assigned to that data block. 
		Blocks are initially named as the input file name with ``:0'' appended. 
		In the examples, data from files ``b'' and ``c'' will be assigned to block ``a''. There can be no spaces in 
		file or block names.
			
			\begin{quote}
					\texttt{"a" "b:0" "c:0"}\\
			\end{quote}
			
		\item [dot:] Specifies that the file contains a graph in `dot' format for use with graph rendering software 
		such as \href{https://en.wikipedia.org/wiki/Graphviz}{GraphViz}.
			
		\item [enewick:] File contains Enhanced Newick format graph of \cite{Cardonaetal2008}.
			
		\item [exclude:] File contains the names of terminal taxa to be excluded from an analysis. Taxa not 
		include in the list, in input files, will be included in analysis. 
			
		\item [fasta:] Ensures that file contents are parsed in fasta \citep{PearsonandLipman1988} format. 
		This is used for single character sequences such as binary streams, IUPAC nucleotide and amino 
		acid sequence data.
			
		\item [fastc:] Ensures that file contents are parsed in fastc \citep{WheelerandWashburn2019} format. 
		This is used for multi-character sequences such as gene synteny, developmental, or linguistic data.
			
		\item [fenewick:] File contains Forest Enhanced Newick format graph of \cite{Wheeler2021a} found 
		\href{https://www.github.com/wardwheeler/euncon}{here}.
			
		\item [include:] File contains the names of terminal taxa to be included in analysis. It is possible to 
		specify terminals that have no data. This may be done to diagnose a large tree on partial data. If 
		there are no data for a leaf taxon, a warning will be printed to stderr. Taxa not include in the list will 
		be excluded from analysis. 
			
		\item [newick:] File contains Newick format graph as specified 
		\href{https://evolution.genetics.washington.edu/phylip/newick_doc.html}{here}.
			
		\item [nucleotide:] File contents are parsed as IUPAC coded nucleotide data in fasta 
			\citep{PearsonandLipman1988} format.
			
		\item [prefasta:] Specifies that the sequences are prealigned in a fasta format, leaving gap characters
			(``-'') in the sequences and alignment correspondences are not re-examined. This option exists to 
			ensure proper parsing (and in case auto-format detection is incorrect).
			
		\item [prefastc:] Specifies that the sequences are prealigned in a fastc format, leaving gap characters
			(``-'') in the sequences and alignment correspondences are not re-examined. This option exists 
			to ensure proper parsing (and in case auto-format detection is incorrect).
			
		\item [rename:] File contains a series of lines, each of which contains at least two strings. The second 
		(and all following) strings (input taxon names),
			will be replaced by the first string (taxon name) on the line. An example file renaming ``b'' and ``c'' 
			to ``a'' and ``Ozzy'' and ``Harriet'' to ``OH''.
				\begin{quote}
					\texttt{"a" "b" "c"}\\
					\texttt{"OH" "Ozzy" "Harriet"}
				\end{quote}
		
		The \texttt{rename} function can also be specified as a command: \texttt{rename("a","b","c")} where 
		``b'' and ``c'' will be rename to ``a''. 
			 
		\item [tcm:] File containing transformation cost matrix to specify varying costs among alphabet elements 
		in a sequence. The first line of the file contains the alphabet elements separated by space (the dash 
		character representing an insertion/deletion or indel character is not specified but added to the alphabet 
		automatically). A square matrix with $n + 1$ ($n$ is the size of alphabet) follows with a row on each line. 
		An extra column at the and of each row and an additional row are added to specify indel costs to and from 
		alphabet elements. At present, this matrix must be symmetrical, but not necessarily metric. Non-metric 
		tcm's can yield unexpected results. Transformation costs must be integers. If real values are desired, a 
		character can be weighted with a floating point value factor. For a sequence with three elements A, B, and 
		C, and an indel cost of 4 for all insertion deletion transformations, a example tcm would be:
		
			\begin{quote}
				A B C\\
				0 1 2 4\\
				1 0 2 4\\
				2 2 0 4\\
			  4 4 4 0\\
		  	 \end{quote}
  		 	  
		\item [tnt:] Ensures that file contents are parsed in TNT \citep{Goloboffetal2008} format. Not all TNT data 
		commands are supported. Files must begin with \texttt{xread}, followed by an optional comment in single 
		quotes ('comment'), the number of characters and taxa. Data follow starting on a new line. Taxon names 
		are followed state data. Data may be in multiple blocks (interleaved) format. These 	blocks may consist 
		of a series of single character states without spaces between them, or multiple (or single) character states 
		(e.g. \texttt{Blue}) with space between the individual codings. Blocks must be of all one type (ie. single 
		character codings without spaces, or multi-character separated by spaces). The data block must be followed 
		by a single semicolon (``;'') on its own line.
			
		Character settings (i.e. \texttt{cc} commands) follow the data block (and semicolon) beginning on a new line. 
		Activity (\texttt{[,])}, addiitivity/ordered (\texttt{+}), non-additivity/unordered (\texttt{-}), matrix costs (\texttt{(}) 
		can be specified with scopes (e.g. \texttt{cc + 10 12;}, \texttt{cc (.; costs 0 = 0/1 1 0/2 2 0/3 3 0/4 4 1/2 1 1/3 2 1/4 3 2/3 1 2/4 2 3/4 1;}) 
		including abbreviated scopes (\texttt{cc -.;}). Each character setting statement must be terminated by a 
		semicolon (\texttt{;}). There may be multiple character setting statements in a single line. 
		  
		Character settings must be followed by \texttt{proc/;} on its own line. \texttt{PhyG} will not process
		any file contents that follow \texttt{proc/;}.
		  
		 Additive/ordered character states must be numbers (integer or floating point). Ranges for continuous
		 characters are specified with a dash wihtin square brackets (e.g. \texttt{[1-2.1]})
		  
		 State polymorphism are specified in square brackets without spaces for
		 single character states, and will spaces for multi-character.
		  
		 \textbf{NB--An important difference between \texttt{TNT} and \texttt{PhyG} is in the treatment of dashes (\texttt{-}).} 
		 Single character dashes are treated as a state (as in sequence or other ``gap'') whereas in TNT, by default they 
		 are missing data (`?'-- unless DNA input is specified). Dashes in multi-character states (e.g. \texttt{Blue-ish}) are 
		 treated as part of the character state specification. If the user wishes that dashes be treated as missing data (`?'), 
		 the file must be edited to reflect this by replacing the dashes that are to be treated as missing data with question 
		 marks (`?').
		  
		  Example file:
		  	\begin{quote}
			  	\texttt{xread\\
				  	'An example TNT file' 5 5\\
				  	A 000\\
				  	B a14\\
				  	C b22\\
				  	D ?33\\
				  	E d04\\}
			  	
			  	\texttt{A Blue-ish -\\
				  	B Green-ish OneFish\\
				  	C Rather-Red TwoFish\\
				  	D Almost-Cyan RedFish\\
				  	E Orange-definitely BlueFish\\
				  	;\\
				  	cc .;\\
				  	cc + 2;\\
				  	proc/;\\}
			  \end{quote}
	\end{description}	
		
	\subsubsection{Defaults}
		\texttt{read("filename")} reads data from filename and attempts to recognize the file type and 
		process it accordingly. The assumed file type is printed to stderr for verification.
		
	\begin{example}
		
		\item{\texttt{read(prefasta:"myDnaSequenceFile.fas")}\\ Reads sequence data from 
		``myDnaSequenceFile.fas'' as prealigned data.}
		
		\item{\texttt{read(rename:"myRenameFile")}\\ Reads a list of taxa and names to be assigned.} 
		
	\end{example}
		
%---------------------------------------------
%reblock
%---------------------------------------------
\subsection{Reblock}
	\subsubsection{Syntax}
		\texttt{reblock("newBlockName", "inputFile0", "inputFile1",...)}
	
	\begin{phygdescription}
	{Command to assign input data to ``blocks'' that will follow the same display tree when optimized
	as ``soft-wired '' networks. By default, each input data file is assigned its own block with the name
	of the input file. The \texttt{block} command is used to reassign these data to new, combined blocks.
	Spaces are not allowed in block names and will produce \texttt{unrecognized block name} errors.}  
	\end{phygdescription}
	
	\subsubsection{Arguments}
		The first argument is the block to be created, the remainder are the input data to be 
		assigned to that block. Blocks are initially named as the input file name with ``:0'' appended. 
		Blocks are reported in \texttt{report(data)} command.
	
	\subsubsection{Defaults}
		None.
	
	\begin{example}

		\item{\texttt{reblock("a","b\#0","c\#0")}\\ Assigns input data from file ``b'' and ``c'' to block ``a''. }
	
	\end{example}

%---------------------------------------------
%rename
%---------------------------------------------	
\subsection{Rename}
	\subsubsection{Syntax}
		\texttt{rename("newName", "oldName1", "oldputName",...)}
		
	\begin{phygdescription}
	{Command to rename taxa. The first string (name) is assigned to taxa with the strings (names) 
	that follow. This can be useful when combining data from different sources, such as GenBank, 
	or in revising names to reflect taxonomic changes.}
	\end{phygdescription}
	
	\subsubsection{Arguments}
		Taxon names to assign and be assigned.
		
	\subsubsection{Defaults}
		None.
		
	\begin{example}
	
		\item{\texttt{rename("a","b","c")}\\ Renames ``b'' and ``c'' to ``a''. }
				
	\end{example}

%---------------------------------------------
%refine
%---------------------------------------------		
\subsection{Refine}
	\subsubsection{Syntax}
		\texttt{refine(option, option,...)}
		
	\begin{phygdescription}
		{Performs edit operations (addition, deletion, move) on network edges, hence only applies to 
		soft-wired and hard-wired graphs.}
	\end{phygdescription}

	\subsubsection{Arguments}
		
		\begin{description}
		\item[annealing[:n]] Specifies that $n$ (default 1) rounds of simulated annealing optimization 
		\citep{Metropolisetal1953, Kirkpatricketal1983, Cerny1985} are performed in concert with 
		\texttt{netAdd}, \texttt{netDel}, and \texttt{netMove}. The acceptance of candidate graphs is 
		determined by the probability $e ^ {- (c_c - c_b)/ (c_b * (k_{max} -k)/ k_{max})}$, where $c_c$ 
		is the cost of the candidate graph, $c_b$ is the cost of the current best graph, $k$ is the step number, 
		and $k_{max}$ is the maximum number of steps (set by the \texttt{steps:m}, default 10) option.
			
		\item[drift[:n]] Specifies that $n$ (default 1) rounds of the ``drifting'' form of simulated annealing \citep{goloboff1999} 
		optimization are performed in concert with \texttt{netAdd}, 	\texttt{netDel}, and \texttt{netMove}. The acceptance of 
		candidate graphs is determined by the probability $1/ (wf + c_c - c_b)$, where $c_c$ is the cost of the candidate 
		graph, $c_b$ is the cost of the current best graph, and $wf$ is the \texttt{acceptWorse} (set by the 
		\texttt{acceptWorse:m}, default 1.0) option. Equal cost graphs are accepted with probability set by the 
		\texttt{acceptEqual} option. \texttt{Drift} differs from \texttt{annealing} in that there are no cooling steps to modify 
		acceptance probabilities. The maximum number of graphs changes is set by \texttt{maxChanges}
			
		\item[generations:[n]] Specifies the number of generations (sequential iterations) for \texttt{geneticAlgorithm}. 
		Default $n=10$.
			
		\item[geneticAlgorithm|ga] Performs Genetic Algorithm \citep{Holland1975} refinement in concert with options \\
		\texttt{generations}, \texttt{popsize}, \texttt{severity}, and \texttt{recombinations}. 
			
		\item[keep:n] Limits the number of returned graphs to $n$. 
		
		\item[netadd] Adds network edges to existing input graphs at all possible positions until no better cost graph is found.
			
		\item[netdel] Deletes network edges from input graphs one at a time until no better cost 
		graph is found.
			
		\item[netmove] Moves existing network edges in input graphs one at a time to new positions 
		until no better cost graph 
		is found.
			
		\item[popsize:[n]] Specifies the population size for \texttt{geneticAlgorithm}. Default $n=20$.
			
		\item[recombinations:[n]] Specifies the number of recombination (fusing) events for 
		\texttt{geneticAlgorithm}. Default $n=100$.
			
		\item[severity:[n]] Specifies the severity of selection against sub-optimal graph solutions events 
		for \texttt{geneticAlgorithm}. The higher the value, the less severe the penalty. Default $n=1.0$.
			
		\item[steps:n] Specifies that $n$ (default 10) temperature steps are performed during simulated 
		annealing (as specified by the \texttt{annealing}) option.
		\end{description}
	
	%add defaults and examples	
%---------------------------------------------
%report
%---------------------------------------------				
\subsection{Report}
	\subsubsection{Syntax}
		\texttt{report("filename", arg0, arg1,...)}
	
	\begin{phygdescription}
		{Outputs various information to file or stderr. When a filename is specified, output is sent to 
		that file. By default, new information printed to a file if appended to the file. The option 
		\texttt{overwrite} overrides the default and rewrites the file. Many of the report options output in 
		csv output that can be easily imported by spreadsheet programs.}
	\end{phygdescription}
	
	\subsubsection{Arguments}
	\begin{description}
		\item[crossrefs] Prints source file presence or absence of input data in csv format. This is 
		useful to check for missing and misnamed taxa.
			
		\item[data] Prints information about of the input data in csv format.
			
		\item[diagnosis] Outputs graph diagnosis information such as vertex and states and edge 
		statistics in csv format. 
		
		\item[displaytrees] Outputs graph information for soft-wired networks. The ``display'' trees 
		are output for each data block. 
		
		\item[graph] Outputs a graph in format specified by the other arguments in the command. 
		These are \texttt{dot} for 
		GraphViz graph format, \texttt{dotpdf} for pdf (or ps for OSX), \texttt{newick} for Newick, 
		ENewick, or ForestEnewick depending on the graph type, \texttt{ascii} for an ascii rendering. 
		In order to output pdf files (via \texttt{dotpdf}) ``dot'' must be installed from 
		\url{https://graphviz.org/download/}. PhyG will not error, but output a ``dot'' file that 
		can be processed later.
		
		\item[pairdist] Outputs a taxon pairwise distance matrix in csv format. 
		
		\item[reconcile] Outputs a single ``reconciled'' graph from all present graphs. The 
		methods include consensus, supertree, and other supergraph methods as described in 
		\cite{Wheeler2012, Wheeler2021a}. When \texttt{reconcile} is specified as a command 
		option a series of other options may be specified to tailor the desired outputs:
					
			\begin{itemize}
			\item {Method:eun$\mid$cun$\mid$majority$\mid$strict$\mid$Adams\\Default:eun\\
			This commands specifies the type of output graph. EUN is the Edge-Union-Network 
			\citep{MiyagiandWheeler2019}, CUN the Cluster Union Network \citep{Baroni2005},
			majority (with fraction specified by `threshold') specifies that a values between 0 and 
			100 of either vertices or edges will be retained. If all inputs are trees with the same leaf 
			set this will be the Majority-Rule Consensus \citep{MargushandMcMorris1981}.
			Strict requires all vertices be present to be included in the final graph. If all inputs are 
			trees with the same leaf set this will be the Strict Consensus \citep{Schuhandpolhemus1980}. 
			Adams denotes the Adams II consensus \citep{Adams1972}.}
							
			\item{Compare:Combinable$\mid$identity\\Default:combinable\\Species how group 
			comparisons are to be made. Either by identical match [(A, (B,C))$\neq$(A,B,C)],
			combinable sensu \cite{Nelson1979} [(A, (B,C)) consistent with (A,B,C)]. This option 
			can be used to specify ``semi-strict'' consensus \citep{Bremer1990}.}
							
			\item{Threshold:(0-100)\\Default:0\\Threshold must be an integer between 0 and 100 
			and specifies the frequency of vertex or edge occurrence in input graphs to be included 
			in the output graph. Affects the behavior of `eun' and` majority.'}
			
			\item{Connect:True$\mid$False\\Default:True\\Specifies the output graph be connected 
			(single component), potentially creating a root node and new edges labeled with ``0.0''.}
			
			\item{EdgeLabel:True$\mid$False\\Default:True\\Specifies the output graph have edges 
			labeled with their frequency in input graphs.}
			
			\item{VertexLabel:True$\mid$False\\Default:False\\Specifies the output graph have vertices 
			labeled with their subtree leaf set.}
	
			\item{OutFormat:Dot$\mid$FENewick\\Default:Dot\\Specifies the output graph format 
			as either Graphviz `dot' or FEN.}
			\end{itemize}	
				
		\item[support] Outputs support graphs. Resampling graphs are independent of the 
		input graphs while Goodman-Bremer are based on current graphs. Multiple formats 
		can be output via additional options including \texttt{dot} for GraphViz graph format, 
		\texttt{dotpdf} for pdf (or ps for OSX), \texttt{newick} for Newick, ENewick, or 
		ForestEnewick depending on the graph type, \texttt{ascii} for an ascii rendering. 
		In order to output pdf files (via \texttt{dotpdf}) ``dot'' must be installed from 
		\url{https://graphviz.org/download/}. \phyg will not error, but output a ``dot'' file that 
		can be processed later.
		
		\item[search] Outputs search statistics in csv format.
		 
	\end{description}			
		
	\subsubsection{Defaults}
		\texttt{report()} prints input data and output graph diagnosis to stderr. Default graph 
		representation is \texttt{dot}.
		
	\begin{example}
		\item{\texttt{report("outFile", newick, overwrite)}\\ Outputs graphs in newick format to 
		``outFile'', overwriting any existing information.}
		
		\item{\texttt{report("outFile", crossrefs)}\\ Outputs presence/absence for taxa in input files. 
		A `+' is output if taxa are present in an input data file, and `-' if. File is in csv format. This 
		can be useful in checking for missing sequence or other data and expected renaming.}
		
		\item{\texttt{report("outFile", dot, reconcile, method:eun, threshold:51)}\\ Outputs reconciled 
		graph using the Edge-Union-Network method with a minimum edge frequency of 51\% in 
		dot format to ``outFile'', appending to any existing information in ``outFile''.}
	\end{example}

%---------------------------------------------
%run
%---------------------------------------------		
\subsection{Run}
	\subsubsection{Syntax}
		\texttt{run("filename")}
		
	\begin{phygdescription}
		{Used to execute a file containing commands. This can be useful to specify common actions 
		such as file inputs and graph construction. }
	\end{phygdescription}
	
	\subsubsection{Arguments}
		The only argument is the filename containing commands to be executed.
		
	\subsubsection{Defaults}
		There are no default \texttt{run} arguments. 
	
	\begin{example}
		\item{\texttt{run("readFiles.pg")}\\ Executes "readFiles.pg", which may contain multiple input 
		files to be \texttt{read}}
		
		\item{\texttt{run("searchCommands.pg")}\\ Executes "searchCommands.pg", which may 
		contain commands defining a common search strategy (e.g. \texttt{build}).}
	\end{example}

%---------------------------------------------
%search
%---------------------------------------------		
\subsection{Search}
	\subsubsection{Syntax}
		\texttt{search(arg0:option, arg1:option, ...)}
	
	\begin{phygdescription}
		{The command is used to reform a timed randomized series of graph optimization methods 
		including building, recombination (fusing), swapping, simulated annealing and drifting, 
		network edge addition/deletion/moving, and Genetic Algorithm. Parameters and order
		randomized. The arguments specify the number of rounds of search (\texttt{instances}, 
		default 1), and duration (\texttt{days}, \texttt{hours}, \texttt{minutes}, and \texttt{seconds}; 
		default 30 seconds). Successive rounds of search (specified by \texttt{iterations}) gather 
		any solutions from previous sequential or parallel rounds as well as any input graphs.
		Since search methods may vary in how long they take, individual iterations may take 
		longer that the specified duration.}
	\end{phygdescription}
			
	\subsubsection{Arguments}
	\begin{description}
		\item[keep:n] Keeps up to $n$ graphs.
		
		\item[days:n] Adds $n$ 24 hour days to search time.
		
		\item[hours:n] Adds $n$ hours to search time.
		
		\item[minutes:n] Adds $n$ minutes to search time.
		
		\item[seconds:n] Adds $n$ seconds to search time.
		
		\item[iterations:n] Specifies number of (potentially parallel) search iterations.
	\end{description}
		
	\subsubsection{Defaults}
		\texttt{search()} Performs 1 iteration of 30 seconds keeping up to 10 graphs.
		
	\begin{example}
		\item{\texttt{search(hours:10, iterations:2)}\\ Performs 2 search iterations (in parallel if the 
		program is executed in parallel) for 10 hours each.}
				
		\item{\texttt{search(hours:10, minutes:30)}\\ Performs a single search iteration for 10 
		hours and 30 minutes.}
	\end{example}
	
%---------------------------------------------
%select
%---------------------------------------------		
\subsection{Select}
	\subsubsection{Syntax}
		\texttt{set(arg0:option, arg1:option, ...)}
	
	\begin{phygdescription}
		{The command is used to set the method and number of graphs to be saved at any point.
		When multiple graphs are present, the \texttt{select} command will specify which of the 
		graphs to keep for further analysis or reporting.}
	\end{phygdescription}
				
	\subsubsection{Arguments}
		\begin{description}
			\item[all] Keeps all graphs.
		
			\item[best] Keeps graphs of best optimality value.
			
			\item[random] Keeps graphs chosen at random.
			
			\item[arg:n] Keeps up to \texttt{n} graphs determined by the argument.
		\end{description}

	\subsubsection{Defaults}
		\texttt{select()} Keeps all unique graphs of best optimality value.
		
	\begin{example}
		\item{\texttt{select(random:10)}\\ Keeps up to 10 graphs, selected at random.}
						
		\item{\texttt{select(best:10)}\\ Keeps up to 10 graphs of best optimality value.}
	\end{example}

%---------------------------------------------
%set
%---------------------------------------------				
\subsection{Set}
	\subsubsection{Syntax}
		\texttt{set(arg0:option, arg1:option, ...)}
	
	\begin{phygdescription}
		{Changes the settings of \phyg. This command performs an array of functions
		from specifying the seed of the random number generator, to selecting a terminal for
		rooting output trees, to specifying  graph type, final assignment, and 
		optimality criterion. All \texttt{set} commands are executed at the start of a run. 
		The command \texttt{transform} is used to modify global settings during a run.}
	\end{phygdescription}
			
	\subsubsection{Arguments}
		\begin{description}
			\item[compressResolutions:True|False] Determines whether soft-wired graph 
			resolutions are ``compressed'' if multiple vertex assignments in alternate display 
			trees are equal.
			
			\item[criterion:parsimony|pmdl] Sets the optimality criterion for graph search to be 
			method. Currently, parsimony and PMDL \citep{WheelerandVaron2022} are supported.
			
			\item[finalAssignment:DirectOptimization|DO|ImpliedAlignment|IA] Sets the method 
			of determining the ``final'' sequence states. DirectOptimization (DO) uses soft-wire the DO 
			method to assign the final states, which is more time consuming than \texttt{ImpliedAlignment}. 
			DO has an additional factor of potentially $O(n^2)$ in sequence length compared 
			to the constant factor for IA due to additional graph traversals.
			
			\item[graphFactor:nopenalty|W15|PMDL] Sets the network penalty for a soft-wired network\\ 
			(\texttt{|W15}) or \texttt{PMDL} (for criterion = PMDL). W15 employs the
			parsimony network penalty of \cite{Wheeler2015}.
			
			\item[graphType:tree|hardwired|softwired] Sets the phylogenetic graph type to tree, 
			hard-wired network, or soft-wired network. Forest are allowed by the network options.
			
			\item[outgroup:"Blah"] Makes the outgroup taxon ``Blah''. 
			
			\item[rootCost:noRootCost|W15|PMDL] Sets the root cost for a graph. W15 sets a 
			cost at $\frac{1}{2}$ the cost of `inserting' the root character assignments. 
			The W15 root cost is based on the same rationale as the parsimony network penalty of
			 \cite{Wheeler2015}.
			 
			 \item[seed:INTEGER] Sets the seed for the random number generator using the integer
			 value. If unspecified, \phyg uses the system time as the seed.
		\end{description}
					
	\subsubsection{Defaults} 
		There are no default \texttt{set} arguments. The default outgroup is the taxon whose name is 
		lexically first after renaming and taxon inclusion/exclusion. For this reason, it is best to specify 
		an outgroup explicitly. The default optimality criterion is \texttt{parsimony}, \texttt{CompressResolutions} 
		is set to \texttt{True}, \texttt{FinalAssignment} is set to \texttt{DirectOptimization}, and the default 
		graph type is \texttt{tree}. The default graphFactor is \texttt{W15} if parsimony is the optimality 
		criterion and \texttt{PMDL} if PMDL is set as the optimality criterion. The default rootCost
		is \texttt{noRootCost} if parsimony is the optimallity criterion and \texttt{PMDL} if PMDL is set 
		as the optimality criterion.
		
	\begin{example}
		\item{\texttt{set(optimality:parsimony)}\\Sets the graph search optimality criterion to parsimony.}
						
		\item{\texttt{set(compressResolutions:False)}\\Turns off soft-wired graph resolution compression.}
	\end{example}

%---------------------------------------------
%support
%---------------------------------------------			
\subsection{Support}
	\subsubsection{Syntax}
		\texttt{swap(arg0, arg1:option, ...)}
		
	\begin{phygdescription}
		{Generates graphs supports via resampling \citep{Farrisetal1996} and Goodman-Bremer 
		\citep{Goodmanetal1982, bremer1994}. Currently, Jackknifing and Bootstrapping 
		are the resampling methods that are implemented.}
	\end{phygdescription}
		
	\subsubsection{Arguments}
		\begin{description}
			\item[buildonly] Performs very rapid, but not extensive graph searches for each 
			resampling replicate.
		
			\item[bootstrap] Specifies that Bootstrap resampling is performed. When reported 
			(via \texttt{report(support)}) edges are labeled with the bootstrap frequencies.
		
			\item[goodmanbremer|gb[:spr|tbr]] Specifies that Goodman-Bremer support is 
			calculated for input graphs. The method traverses the SPR or TBR neighborhood 
			as optionally specified (TBR as default) to determine an upper bound on the NP-hard 
			values (this is the method used in POY v2; \citealp{POY2} \textit{et seq.}). The number 
			of alternate graphs to be examined can be specified (\textit{ie.} limited) by \texttt{gbsample:[n]}. 
			When \texttt{gbsample:[n]} is specified, graphs are chosen uniformly at random.
		
			\item[jackknife:[n]] Specifies that Jackknife resampling is performed with $n$ acceptance 
			probability (default 0.6231 or $1 - e^{-1}$). When reported (via \texttt{report(support)}) 
			edges are labeled with the jackknife frequencies.
		
			\item[replicates:n] Specifies that $n$ resampling replicates (default 100) are performed 
			in resampling support.
		\end{description}	
		\subsubsection{Defaults}
			\texttt{support(goodmanBremer:TBR)}
		

		\begin{example}
			\item{\texttt{support(jackknife:0.50, replicates:1000)}\\Performs 1000 replicates of 
			delete 50\% jackknife resampling.}
				
			\item{\texttt{support(gb:SPR, gbSample:10000)}\\Produces Goodman-Bremer 
			support based on $10,000$ samples of 
						the SPR neighborhood.}
		\end{example}

%---------------------------------------------
%swap
%---------------------------------------------		
\subsection{Swap} 
	\subsubsection{Syntax}
		\texttt{swap(arg0, arg1:option, ...)}
			
	\begin{phygdescription}
		{Performs branch-swapping rearrangement on graphs. These include ``NNI'' \citep{CaminandSokal1965, 
		Robinson1971}, ``SPR'' \citep{Dayhoff1969}, and ``TBR'' \citep{Farris1988, swofford1990a} refinement.}
	\end{phygdescription}
		
	\subsubsection{Arguments}
		\begin{description}
			\item[all] Specifies that refinement examines the entire rearrangement neighborhood 
			of the current graph before retaining the best (lowest cost) solutions.
		
			\item[annealing[:n]] Specifies that $n$ (default 1) rounds of simulated annealing \citep{Metropolisetal1953, 
			Kirkpatricketal1983, Cerny1985} optimization are performed. The acceptance of candidate 
			graphs is determined by the probability $e ^ {- (c_c - c_b)/ (c_b * (k_{max} -k)/ k_{max})}$, 
			where $c_c$ is the cost of the candidate graph, $c_b$ is the cost of the current best graph, $k$ 
			is the step number, and $k_{max}$ is the maximum number of steps (set by the \texttt{steps:m}, 
			default 10) option.
		
			\item[drift[:n]] Specifies that $n$ (default 1) rounds of the ``drifting'' form of simulated annealing 
			\citep{goloboff1999} optimization are performed. The acceptance of candidate graphs is determined 
			by the probability $1/ (wf + c_c - c_b)$, where $c_c$ is the cost of the candidate graph, $c_b$ is 
			the cost of the current best graph, and $wf$ is the \texttt{acceptWorse} (set by the \texttt{acceptWorse:m}, 
			default 1.0) option. Equal cost graphs are accepted with probability set by the \texttt{acceptEqual} 
			option. \texttt{Drift} differs from \texttt{annealing} in that there are no cooling steps to modify acceptance 
			probabilities. The maximum number of graphs changes is set by \texttt{maxChanges}
		
			\item[ia] Specifies that Implied Alignment \citep{Wheeler2003} assignment are used for branch swapping 
			as opposed to full Direct Optimization for dynamic charters when the graph type is \texttt{Tree}.
		
			\item[keep:n] Specifies that up to $n$ equally costly graphs are retained.
		
			\item[maxChanges:n] Specifies that drifting graph changes are limitied to $n$ (default 15).
		
			\item[nni] Specifies that NNI refinement \citep{CaminandSokal1965, Robinson1971} is performed.
		
			\item[spr:[n]] Specifies that SPR refinement \citep{Dayhoff1969} is performed. If the optional 
			argument $n$ is specified, readdition of pruned graphs will be within $2 * N$ edges of its original 
			placement.
		
			\item[steps:n] Specifies that $n$ (default 10) temperature steps are performed during simulated 
			annealing (as specified by the \texttt{annealing}) option.
		
			\item[steepest] Specifies that refinement follows a greedy path, abandoning the neighborhood 
			of the current graph when a better (lower cost) graph is found.
		
			\item[tbr:[n]] Specifies that TBR refinement \citep{Farris1988, swofford1990a} is performed. If the 
			optional argument $n$ is specified, readdition of pruned graphs will be within $2 * N$ edges of its 
			original placement.
		\end{description}	
		
		\subsubsection{Defaults}
			\texttt{swap(spr, keep:1, steepest)}
		
		\begin{example}
			\item{\texttt{swap()}\\Performs spr branch swapping on each current graph returning the single 
			best rearrangement found for each graph employing steepest descent.}
			
			\item{\texttt{swap(tbr, all, keep:10)}\\Performs tbr branch swapping on each current graph 
			returning up to 10 best rearrangements found for each graph after examining all graphs in 
			the rearrangement neighborhood.}
		\end{example}
		
%---------------------------------------------
%transform
%---------------------------------------------		
\subsection{Transform}
	\subsubsection{Syntax}
		\texttt{transform(arg0, arg1,...)}
			
	\begin{phygdescription}
		{\texttt{Transform} modifies global setting during program execution (as opposed to the \texttt{set} 
		command that operates at the inauguration of calculations). The command allows for changing 
		graph (e.g. Tree to Softwired Network) and data types (between dynamic and static approximation) 
		among other operations.}
	\end{phygdescription}
			
	\subsubsection{Arguments}
		\begin{description}
			\item[atRandom] In concert with \texttt{displayTrees:n} specifies that displays trees are chosen 
			uniformly at random for each input graph.
			
			\item[displayTrees:[n]] When this option is specified, returns $n$ display trees for each graph 
			determined by the optional argument If the number of display trees is not 
			specified, 10 are returned. Used in concert with \texttt{toTree}.
			
			\item[dynamic] Reverts data type to the default ``dynamic'' for all dynamic homology 
			\citep{Wheeler2001} character types (e.g. DNA sequences). After this command, 
			graph optimization proceeds in the default manner with sequence characters treated 
			in their non-aligned (``dynamic'') condition.
			
			\item[first] In concert with \texttt{displayTrees:n} specifies that the first $n$ displays tree 
			resolutions are chosen for each input graph..
			
			\item[staticApprox] Converts non-aligned (``dynamic'') sequence characters to their Implied 
			Alignment \citep{Wheeler2003, WashburnandWheeler2020} condition.
			
			\item[toHardwired] Converts exiting graphs to hardwired network graphs.
			
			\item[toSoftwired] Converts exiting graphs to softwired network graphs.
			
			\item[toTree] Converts exiting graphs to trees. For both Softwired and Hardwired graphs 
			this proceeds via graph resolution of network nodes into ``display'' trees. Since there are up to 
			$2^n$ display trees for a graph with $n$ network nodes, this number can be quite large. 
			The number of display trees produced for each graph is controlled via the options 
			\texttt{displayTrees:n}, \texttt{atRandom}, and \texttt{first}. 
		\end{description}
			
		\subsubsection{Defaults}
			None.
		
		\begin{example}
			\item{\texttt{transform(toSoftwired)}\\Converts each current graph to a softwired network graph.}
					
			\item{\texttt{transform(staticApprox)}\\Changes data to all static characters via Implied Alignment 
			for further analysis.}
					
		\end{example}
	
