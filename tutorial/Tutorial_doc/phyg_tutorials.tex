\documentclass[11pt]{article}
\usepackage{longtable}
\usepackage{color}
\usepackage{tabu}
\usepackage{setspace}
\usepackage{pdflscape}
\usepackage{graphicx}
\usepackage {float}
%\usepackage{subfigure}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{natbib}
\usepackage{fullpage}
\bibliographystyle{plain}
%\bibliographystyle{cbe}
\usepackage{algorithmic}
\usepackage[vlined,ruled]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{url}
 
\usepackage[dvipsnames]{xcolor}
\usepackage{color, soul}
\usepackage[colorlinks=true, linkcolor=blue, citecolor=DarkOrchid, urlcolor=TealBlue ]{hyperref}
%\usepackage[nottoc,numbib]{tocbibind}
\usepackage{tocloft}


\setlength\itemindent{0.25cm}

\newcommand{\phyg}{\texttt{PhyG} }
\newcommand{\BigO}[1]{\ensuremath{\mathcal{O}\left(\,#1\,\right)}\xspace}

\title{PhyG 0.1 Tutorials}

\author{Louise M. Crowley}
\makeindex
\begin{document}
\maketitle


%Maybe add:\\
%\begin{enumerate}
%	\item{reports of diagnosis}
%	\item{Supports--Goodman-Bremer, bootstrap, jackknife--maybe on chel or 
%	something preassigned and small}
%	\item{Consensus etc outputs}
%\end{enumerate}

\section{\phyg Tutorials}

These tutorials are intended to provide guidance for using the phylogenetic 
program \texttt{PhyG}. Each tutorial contains a \phyg script that includes 
detailed commentaries explaining the rationale behind each step of the analysis. 
The command arguments will differ substantially depending on type, complexity, 
and size of the data set. The values of arguments within this tutorial have been 
chosen such that the analysis can complete within the timeframe of this session.
Therefore, the values used here should not be taken to be optimal parameters. 

The tutorials use sample datasets that can also be downloaded from the \texttt{PhyG} 
\href{https://github.com/amnh/PhyGraph}{GitHub} website. The minimally required 
items to run the tutorial analyses are the \phyg application and sample data files. 
Running these analyses requires some familiarity with the \phyg command structure 
that can be found below (see Section \ref{subsec:Scripts}). A complete guide to the
commands and associated arguments of \phyg can be found 
\href{https://github.com/amnh/PhyGraph}{here}.

%-------------------------------------------------------------------------------------------------------
\subsection{Obtaining and Installing \phyg}
\label{subsec:Installation}

In this tutorial, you will learn how to obtain and install the \phyg binaries. \phyg 
precompiled binaries, test data, and documentation in pdf format, are available 
from the \phyg \href{https://github.com/amnh/PhyGraph}{GitHub} website. 

\begin{enumerate}
\item Open a web browser, and navigate to the \phyg \href{https://github.com/amnh/PhyGraph}
{GitHub} website. In the \emph{bin} directory, binaries are available for Mac OSX 
computers with either Intel or M1 processors, and Linux (Intel) machines (see information 
relating to Windows machine below).

\item Click on the appropriate link for the binary. On most systems this will 
download to either your Desktop or Downloads folder. 

\item The user is advised to change the permissions of the binary to ensure
that it is executable. In a terminal window, navigate to the directory where the \phyg
binary is located. Type the following:

	\begin{quote}
	chmod +x phyg
	\end{quote}

\item With Mac OSX machines, right click on the binary, and select `open with 
\emph{Terminal}', and click ``Open.'' The OSX has now marked the binary as `safe' 
to open. In Linux machines, it is not necessary to mark executables as `safe'.

\item The binary should either be moved into your \$PATH or referred to its 
absolute PATH when executing a script. Your \$PATH is a colon-separated list 
of directories, the contents of which you can execute without specifying the 
absolute path. To find out what's in your \$PATH, open a \textit{Terminal} window 
(located in your Applications folder) and type: 

	\begin{quote}
	echo \$PATH
	\end{quote}

If the directories \texttt{/usr/local} or \texttt{/usr/local/bin} do not exist yet, type the 
following (\texttt{sudo} will require Admin password): 

	\begin{quote}
	sudo mkdir -p /usr/local/bin
	\end{quote}

\item Should the user wish to 
\item Move the \phyg binary from its current location to this location. For example 
typing the following will move the binary from its Desktop location into the user's 
\$PATH:

	\begin{quote}
	sudo mv ~/Desktop/phyg /usr/local/bin
	\end{quote}
	
\item For those users with Windows machines, a Windows Subsystem for Linux 
(WSL) can be installed. This system will allow you to run the Linux binary directly 
on your machine, without having to install a virtual machine or dual-boot setup. 
The WSL, along with directions for installation, can be found 
\href{https://learn.microsoft.com/en-us/windows/wsl/}{here}.
\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Making a \phyg script}
\label{subsec:Scripts}

\phyg analyses are conducted using a script, and can not be performed interactively. 
A script is a simple text file containing a list of commands to be performed. In this 
tutorial you will learn how to generate a script for execution by the program. \phyg 
scripts can be created and saved using any conventional text editor (such as 
\textit{TextEdit}, \textit{TextWrangler}, \textit{BBEdit}, \textit{Emacs}, or \textit{NotePad}). 
Do not use a word processing application like \emph{Microsoft Word} or \emph{Apple 
Pages}, as these programs can introduce hidden characters in the file, which will be 
interpreted by \phyg and can cause unpredictable parsing of the data. In this tutorial, 
you will learn about the format of \phyg scripts and how to make them.

\begin{enumerate}

\item Open your text editor of choice.

\item Type the following:
	
	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	\end{quote}

Note: the commands \texttt{read}, \texttt{rename}, \texttt{reblock}, and \texttt{set} 
are executed at the beginning of program execution, irrespective of where they 
appear in the command script. All other commands are executed in the order they 
are specified.

\item In this example, the script begins with a comment that describes the 
contents of the file. Comments are prepended with `-{}-' and can span multiple 
lines, provided each line begins with `-{}-'. \phyg will ignore any commented 
lines. Comments can provide useful information to the reader to understand 
the purpose of the script. They can also be useful for testing purposes.

\item Each command consists of a name, followed by a list of arguments or options 
separated by commas and enclosed in parentheses. Commands and arguments are 
case insensitive with the exception of filename specifications, which are always in 
double quotes (\textbf{"fileName"}). There are defaults for all options except 
input graphs. The command, followed by open and closed parentheses `\texttt{()}',
denotes default options, e.g. \texttt{build()} is the equivalent of \texttt{build(character, 
replicates:10)}.

\item In this script, the seed for the random number generator is \texttt{set} to 
the integer value 73412305. By setting this value, you are guaranteed to reproduce 
a given search strategy each time the script is run. This value can be any number of 
digits in length. Note: this seed value should not be mistaken for the initial random
seed value, as chosen by the application (see Figure \ref{output1}).

\item Next \texttt{set} the outgroup for the analysis to \emph{Limulus}. If the outgroup
is not set, \phyg will sort the taxa alphabetically and choose the first taxon as the
outgroup. Only a single taxon can be set as the outgroup of the analysis. Note: taxon 
names can not have spaces, otherwise the names can be incorrectly interpreted by
the program.

\item The command \texttt{read} imports file-based information, including data files, 
tree and graph files. \texttt{read} commands must contain an input file. Supported 
data formats include FASTA, FASTC and TNT files, and graph formats include Dot, 
Enewick, Fenewick, and Newick. Filenames must include the any suffix (e.g. 
.fas, .fasta, .fastc, .ss, .tre). Failure to include these suffices will result in the error 
"File(s) not found in `read' command". The filename must match \textit{exactly}, 
including capitalization.\\
\\
\texttt{read} also accepts wild cards. The user can use an asterisk (*) to represent 
zero or more characters. For example, to read all the filenames with the extension .fas, 
the user can simply type:
        
        \begin{quote}
	read(nucleotide:"*.fas")\\
	\end{quote}
	
Moreover, to capture all the filetypes beginning with fas, the user can type: 
	
	\begin{quote}
	read(nucleotide:"*.fas*")\\
	\end{quote}

This will read files ending in .fas, .fasta and .fastc. \phyg will attempt to recognize 
the type of input and parse appropriately. Otherwise, the type of file can be 
indicated. In this example, we indicate that the files "chel\_16S.fas" and 
"chel\_cox1.fas" contain IUPAC \texttt{nucleotide} sequence data in fasta format.

\item Having read in our data, it is advisable to verify that the files were properly 
parsed by checking the characters and terminals in the cross references and data 
files. We will examine these files below (Section \ref{subsec:Inspecting}).

\item Save this file with the name \textbf{run1.pg} in a directory \texttt{phygfiles} 
located on your Desktop.

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Executing scripts}
\label{subsec:Execution}

In this tutorial you will learn how to execute a script using \texttt{PhyG}. 

\begin{enumerate}

\item Before we read the data, we will make sure that \phyg is working in the directory 
containing the data files. The working directory tells the application where to look 
for the files. In this way, whenever we tell \phyg to read a file, we don't need to 
specify where is it located in the file system, we can simply use its name. To 
begin, open a \textit{Terminal} window.
        
\item Change the directory to where the script \textbf{run1.pg} is located by using the 
\texttt{cd} command, as in:
		
	\begin{quote}
	cd ~/Desktop/phygfiles
	\end{quote}
   
\item By typing \texttt{ls} you will see that this directory contains the script 
\textbf{run1.pg}.

\item The program is invoked from the command-line, as in:
		
	\begin{quote}
	phyg commandFile
	\end{quote}
	
To run the script \textbf{run1.pg} type the following:
		
	\begin{quote}
  	phyg run1.pg
	\end{quote}
	
This is equivalent to typing the following from any location on your computer:
	
	\begin{quote}
  	phyg ~/Desktop/phygfiles/run1.pg
	\end{quote}

Note: should you get the error ``phyg: command not found'' this indicated that 
\texttt{Phyg} is not in your path). 
	
\item To interrupt the analysis, press control-c. Interrupting the analysis cancels 
the execution of the last command requested by the user. 

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Inspecting the data}
\label{subsec:Inspecting}

In this tutorial you will learn how to inspect data in both the terminal window and 
in reported output files. Running the script will automatically generate an extensive, 
detailed output in the terminal window. It may also be desirable to inspect the 
imported data in greater detail to ensure that the format and contents of the files 
have been interpreted correctly. This practice helps avoid common errors, such 
as inconsistently spelled terminal names, which may result in bogus results, 
produce error messages, and aborted jobs.

\begin{enumerate}

\item Having run the script, examine the output in the terminal window 
(Figure \ref{output1}). \phyg will continue to output information to the screen 
until the completion of the analysis. It is possible to scroll through this output, 
even as the analysis continues to run. The output includes the landing page, 
the name of the script, the random seed, whether the files were 
correctly specified, the name of the input file(s), whether the terminals were 
renamed, whether trees were selected, and a brief description of the content 
for each loaded file. The current state of the analysis can be viewed here. Any 
warnings and errors will also appear here. Upon completion of the analysis, the 
results, including costs, the number of returned graphs, and information relating 
wall-clock time, CPU time and CPU usage are also provided.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{output1.png}
\caption{The \phyg output display in the \emph{Terminal} window at the beginning 
of an analysis.}
\label{output1}
\end{figure}

\item A good practice is to confirm that \phyg parsed the input files correctly. 
By examining the output in the terminal, you can see that both files were
interpreted and read in as nucleotide sequence data files by the program 
(Figure \ref{output1}).

\item Let's reexamine our script:

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	\end{quote}
	
Having imported our data files, we next \texttt{report} a crossrefs and data file.
The command \texttt{report} outputs the results of the current analysis or loaded 
data by directing it to a file. To redirect the output to a file, the file name (in quotes), 
followed by a comma, must be included in the argument list of report. All arguments 
for \texttt{report} are optional. This command allows the user to output information 
concerning the characters and terminals, diagnosis, export static homology data, 
implied alignments, trees, graphs, dot files, as well as other miscellaneous arguments. 
By default, new information printed to a file is appended to the file. The option 
\texttt{overwrite} overrides the default and rewrites the file rather than appending 
to the existing information. Many of the report options can be output in csv format, 
which can subsequently be imported into spreadsheet applications like \textit{Excel} 
or \textit{Numbers} for easy viewing. 

\item Examine the reported file \textbf{"chel\_cr1.csv"}. The \texttt{crossrefs} 
argument of the \texttt{report} command is a useful tool for visual representation 
of the inputted data. This argument displays whether data are present or absent 
for each terminal in each of the imported data files. This provides a comprehensive 
visual overview of the completeness of the data. It will highlight missing data, as 
well as inconsistencies in the spelling of taxon names in different data files (see 
Figure \ref{crossrefs}). The argument will report a file with the terminals represented 
in rows, and the data files in columns. A plus sign ``+'' indicates that data for a given 
terminal is present in the corresponding file; a minus sign ``-'' indicates that it is not.

\item Open the csv file using  your spreadsheet program of choice (Figure \ref{crossrefs}). 
The user is encouraged to report a crossrefs file having imported the data 
into \texttt{PhyG}, especially when working with new datasets. 

\begin{figure}
\centering
\includegraphics[width=0.45\textwidth]{crossrefs1.png}\hfill
\includegraphics[width=0.45\textwidth]{crossrefs2.png}
\caption{Inspecting imported data. The figure shows two crossrefs files, which have 
been imported into \emph{Excel}. The image on the left illustrates an inconsistency in the 
naming of the taxon \emph{Thelichoris}. This was corrected in the image on the right.}
\label{crossrefs}
\end{figure}
	
\item Examine the reported file \textbf{"chel\_data1.csv"}. This file is a summary 
of different aspects of the input data and terminals. This file summarizes 
information relating to the input data (number of terminals, number of input files, 
number of character blocks and the total number of characters). It also provides
information relating to the terminal taxa included in the analysis, including the 
names of the taxa, a list of the excluded taxa (if any), and whether any terminal 
were renamed. In this file you will also see information relating to 
``Index'', ``Block'', ``Name'', ``Type'', ``Activity'', ``Weight'', ``Prealigned'', ``Alphabet'', 
``TCM''. ``Index'' reports the character number in the overall dataset; ``Name'' the 
name of the character (by default based on its source data file); ``Type'' is the type 
of character (e.g. Non-Additive, Matrix, Nucleotide Sequence), ``Activity'' whether
the character is active (included in the analysis) or not (excluded), ``Weight'' is the 
weight of the character, ``Prealigned''  denotes whether a sequence character 
(e.g. amino acids) is to treated as prealigned or not, ``Alphabet'' the elements of 
a sequence character, ``TCM'' is the transition cost matrix specifying costs among 
sequence elements and ``gap'' or insertion-deletion.
\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Building a tree with nucleotide sequence characters}
\label{subsec:Building}

Having imported and inspected our data, we are now ready to build the initial trees 
or graphs. In this tutorial you will build a distance tree using nucleotide sequence 
characters. The \texttt{build} command builds initial graphs. The arguments of build 
specify the number of graphs to be generated, and whether the build is based on 
distance or character methods. Distance methods are considerably faster, but 
approximate in terms of character-based methods. 

\begin{enumerate}

\item Modify the script to include \texttt{build(distance, rdwag, replicates:100)}. 
Specifying \texttt{distance} causes a pairwise distance matrix to be calculated 
($\BigO n^2$) and is used as a basis for distance tree construction. The tree is 
then constructed by performing random addition sequence distance Wagner 
builds, yielding multiple trees determined by the argument \texttt{replicates:n}. 
This method has a time complexity of $\mathcal{O} \left( m*n^2 \right)$.

\item We now want to examine the resulting trees. Trees are not reported as 
output in the terminal window and must be directed to a file. Modify the script 
to output tree files with \texttt{report("chel\_run1.tre", newick, graphs, overwrite)}.

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	\end{quote}
	
\item Examine the reported file \textbf{"chel\_run1.tre"} in your preferred text editor. 
\texttt{report(graph)} outputs a graph in a format specified by other arguments in the 
command, in this case \texttt{newick}. \phyg will \texttt{overwrite} any existing trees in 
this file. This newick tree file, in parenthetical notation, can be viewed in other programs 
like \textit{FigTree} or \textit{TreeView}. The values associated with the taxon names and 
HTUs are the branch lengths. The cost of the tree(s) can be found in square brackets, at 
the end of each tree. Notice that the trees appear in order of cost in the file, with the most 
optimal tree appearing last. In this analysis, \phyg returned 100 trees ranging in cost from 
1005 to 1046 with the cost of the most optimal tree being 1005.

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Performing a local search}
\label{subsec:localsearch}

Now that trees have been generated and stored in memory, a local search can be 
performed in order to refine and improve the initial trees by examining additional 
topologies of potentially better cost. The command \texttt{swap} is the basic local 
search function of \phyg and performs branch-swapping rearrangement on graphs. 
This command proceeds by clipping parts of the given tree and attaching them in 
different positions. These algorithms employed in this branch-swapping include 
`NNI', `SPR' and `TBR' refinement. The default of \texttt{swap} performs alternating 
rounds of `SPR' and `TBR' refinement, swapping iteratively until a local optimum 
is found, keeping 10 graphs per input graph.

\begin{enumerate}

\item Modify the script to include \texttt{swap(alternate, keep:10)}. This command 
specifies that alternating rounds of \texttt{spr} and \texttt{tbr} refinement are performed. 
After each round \phyg will \texttt{keep} 10 graphs per input graph.

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	swap(alternate, keep:10)\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	\end{quote}
	
\item Now reexamine the reported file \textbf{"chel\_run1.tre"}. Notice that this 
simple local search has reduced the cost of the initial best tree from 1005 to 998.

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Selecting trees}
\label{subsec:Selecting}

So far we have performed the basic steps of importing character data, building 
initial trees, and conducting a simple local search. In this tutorial we will select 
trees at various stages of the analysis. 

\begin{enumerate}

\item It may be useful to \texttt{select} all topologically unique trees during the 
analysis. Contra \texttt{select()}, which selects topologically unique and optimal 
trees, \texttt{select(unique)} selects all unique trees (after collapsing zero-length 
branches), regardless of cost. This is a useful command that ensures that a 
larger tree space is explored. Modify the script to \texttt{select(unique)} tree(s) 
following the distance \texttt{build}. If this is used as an option during the 
search, the user should remember to \texttt{select()} at the end of the run, 
prior to reporting the results. The remaining trees are deleted from memory.

\item Generally, users will want to \texttt{select} only those trees that are both 
optimal \emph{and} topologically unique at the end of an analysis. The default 
setting of the \texttt{select()} does exactly that. Add \texttt{select()} to our script, 
ensuring that \phyg will select the topologically unique trees of best cost upon 
completion. For now we will comment out this command as we will only include 
a pool of topologically unique tree for the next stage of the analysis (Section 
\ref{subsec:Fusing}).

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	select(unique)\\
	swap(alternate, keep:10)\\
	-\/-select()\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	\end{quote}

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Performing tree recombination}
\label{subsec:Fusing}

The command \texttt{fuse} performs tree fusing on the trees in memory. Tree 
fusing can be used to escape local optima. \texttt{fuse} operates on a collection 
of graphs performing reciprocal graph recombination between pairs of graphs. 
Non-identical subgraphs with identical leaf sets are exchanged between graphs 
and the results evaluated. This process of exchange and evaluation continues 
until no new graphs are found. Note: more than one tree must be stored in 
memory in order to perform this operation.

\begin{enumerate}

\item Modify the script to include \texttt{fuse(tbr:10, keep:1)}. This command 
causes the exchanged subgraphs to be tried at multiple positions (up to 9 
edges away from their initial positions. The number of returned graphs is 
limited to 1.

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	select(unique)\\
	swap(alternate, keep:10)\\
	fuse(tbr:10, keep:1)\\
	select()\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	\end{quote}

\item Uncomment the command \texttt{select()}.

\item Reopen the reported tree file \texttt{"chel\_run1.tre"} using your text editor.
You will see that the cost of the most optimal tree has not decreased any further 
than 998. While the cost of the tree has not decreased any further, this gives us
some confidence that the large tree space that we explored did not find any
other more optimal trees.

\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Reporting an implied alignment}
\label{subsec:ia}

Another useful way to view the data is to \texttt{report} the implied alignment of the 
molecular data currently loaded. An implied alignment is a representation of the 
insertion, deletion and substitution events that take place on a \emph{given} tree, 
represented as an alignment. Outputted implied alignments can be imported into 
visualization program such as \emph{BioEdit} and \emph{Clustal}, as well as other 
phylogenetic programs such as \emph{TNT}---this will be done during another lab 
session. 

\begin{enumerate}

\item Modify the script to include \texttt{report("fileName", ia)}.

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	select(unique)\\
	swap(alternate, keep:10)\\
	fuse(tbr:10, keep:1)\\
	select()\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	report("chel\_ia1.fas", ia, overwrite)\\
	\end{quote}
	
An implied alignment is output for each reported tree, as well as for each block of imported data.

\item Should the user wish to output an implied alignment that is readable by the 
program \emph{TNT}, they should adjust the command  replacing \texttt{ia} with the
argument \texttt{tnt}.

	\begin{quote}
	report("chel\_ia1.ss", tnt, overwrite)\\
	\end{quote}
	
\end{enumerate}

%-------------------------------------------------------------------------------------------------------
\subsection{Reporting publication quality trees}
\label{subsec:dotpdf}

Publication quality trees can be reported with \texttt{PhyG}. These pdf files can  
subsequently be displayed, edited, and printed using graphics software.

\begin{enumerate}

\item In order to output pdf files the application \emph{dot} must be installed from 
the \href{https://graphviz.org/download/}{Graphviz} website. \emph{dot} is a graph 
description language and Graphviz an  open source graph visualization software. 
This program is well suited to representing graphs and networks.

\item  The command \texttt{report("filename.dot", graphs, dotpdf, overwrite)} will 
produce a file that can be read in \emph{Adobe Illustrator}, \emph{Apple Preview} 
or any vectorial image edition program. Modify the script to include this command:

	\begin{quote}
	-\/-Chel first analysis\\
	set(seed:73412305)\\
	set(outgroup:"Limulus")\\
	read(nucleotide:"chel\_16S.fas")\\
	read(nucleotide:"chel\_cox1.fas")\\
	build(distance, rdwag, replicates:100)\\
	select(unique)\\
	swap(alternate, keep:10)\\
	fuse(tbr:10, keep:1)\\
	select()\\
	report("chel\_cr1.csv", crossrefs, overwrite)\\
	report("chel\_data1.csv", data, overwrite)\\
	report("chel\_run1.tre", newick, graphs, overwrite)\\
	report("chel\_ia1.fas", ia, overwrite)\\
	report("chel\_run1.dot", graphs, dotpdf, overwrite)\\
	\end{quote}
	
\item Notice that two files were outputted from using this command. \phyg has 
output a ps (on OSX) or pdf (on linux) file that can be viewed in a vector graphics program and a dot 
file, which can be viewed (and modified) in \emph{Graphviz}.
The file \textbf{"chel\_run1.dot"} 
\end{enumerate}

%\section{Loading and using Non-additive (Unordered, Fitch) characters}
%
%    \item
%        In this tutorial we will not build new trees, we just want
%        to show that the same \ phyg{read} command works to read both regular
%        \emph{data} and \emph{trees}. To do this, we read from separate files, one
%        containing the character matrix of non-additive characters, and the
%        other containing the trees:
%        \begin{verbatim}
%            read ("1Fitch.ss", "1Fitch.tre")
%        \end{verbatim}
%
%\section{Loading and using Additive characters}
%
%\begin{enumerate}
%    \item Once more, we will repeat (more or less) what we did for Non-additive
%        characters with Additive (Ordered, Wagner) characters. To do this, open
%        the interactive console, and move to the exercises directory.
%
%    \item
%        This time we will input the data contained in the '31' files:
%        \begin{verbatim}
%            read ("31.ss", "31.ss.tree")
%        \end{verbatim}
%
%    \item 
%        Here, we will use report not only to create the contents as
%        before, but  also output the trees in human readable format to the
%        screen. To do this, repeat these commands one by one, and observe the
%        effect:
%        \begin{verbatim}
%            report ("Wagner_results.txt", data, diagnosis)
%            report (trees:(total))
%            report (asciitrees)
%            exit ()
%        \end{verbatim}
%        Can you guess what the command would be to output the asciitrees in a
%        file?
%
%\end{enumerate}
%
%\subsection{Loading a Direct Optimization Sequence}
%
%\begin{enumerate}
%    \item 
%        Again change to the
%        exercises directory (Section~\ref{sec:loading_sankoff}), and read the
%        files \ phyg{3.fasta} and \ phyg{5.fasta}. Both contain sequences in FASTA
%        format:
%        \begin{verbatim}
%            read ("3.fasta", "5.fasta")
%        \end{verbatim}
%
%    \item
%        We will now construct 10  Wagner trees with the
%        command \ phyg{build} (the default), then select the best unique trees resulting from
%        the Wagner builds and report the trees in parenthetical notation:
%        \begin{verbatim}
%            build ()
%            select ()
%            report (trees:(total))
%        \end{verbatim}
%
%    \item
%        We are done for now with this tutorial. Close the
%        interactive console:
%        \begin{verbatim}
%            exit ()
%        \end{verbatim}
%\end{enumerate}
%
%\subsection{Trees argument}
%
%\begin{enumerate}
%    \item By default, from every starting tree, phyg will only store one
%        resulting tree. That is, if you do:
%        \begin{verbatim}
%            build (1)
%            swap ()
%        \end{verbatim}
%        You are guaranteed to end with one tree in memory. What about
%        other trees of the same cost that could be found during the search? In
%        order to increase the number of trees held in memory, after
%        \ phyg{swap}, you can use the \ phyg{trees} argument:
%        \begin{verbatim}
%            use ("initial")
%            select (best:1)
%            report (treestats)
%            swap (trees:10)
%        \end{verbatim}
%        Did you get more than one tree at the end?
%
%    \item 
%        We can also keep suboptimal trees in memory by using the
%        \ phyg{threshold} argument. This allow us to find trees that are at
%        most some number of steps longer than the current optimum. For example,
%        try the following:
%        \begin{verbatim}
%            use ("initial")
%            select (best:1)
%            swap (threshold:20, trees:10)
%            report (treestats)
%        \end{verbatim}
%        How many trees did you get? What are the minimum and maximum lengths?
%
%    \item
%        You can also provide a constraint file from an input file. Let's try
%        that setup. First create the consensus file:
%        \begin{verbatim}
%            use ("initial")
%            select (best:3)
%            report ("constraint.txt", consensus)
%        \end{verbatim}
%        Now open the \ phyg{constraint.txt} file and delete the title at the
%        beginning. We are ready to proceed with the swap:
%        \begin{verbatim}
%            swap (constraint:("constraint.txt"), timeout:10)
%        \end{verbatim}
%        Notice that this time we have also added a timeout of 10 minutes. The
%        main difference between using the constraint file in this way with the
%        automated constraint in the previous item is that the reported consensus
%        tree collapse zero length branches.
%
%\subsection{Modifying your characters with transform}
%
%\begin{enumerate}
%    \item 
%        Your input characters can be modified in many ways, for example to 
%        use a particular cost or
%        weighting scheme, as well as to modify the type of character being
%        analyzed. To begin this series of exercises, let's start with our
%        typical data set:
%        \begin{verbatim}
%            read ("course.fasta")
%        \end{verbatim}
%
%    \item
%        Now we will report the cost matrix being used in the loaded characters:
%        \begin{verbatim}
%            report (data)
%        \end{verbatim}
%
%    \item 
%        You can see that by default phyg will give cost 2 to each indel, and 1 to
%        every substitution (that's what the \ phyg{tcm:(1,2)} means). We can
%        modify all the characters with the command \ phyg{transform}, as
%        follows:
%        \begin{verbatim}
%            transform (tcm:(1,1))
%        \end{verbatim}
%        This will change will the characters for which a transformation cost
%        matrix for an alignment is applicable. \ phyg{tcm:(1,1)} will assign
%        cost 1 to every substitution and 1 to every indel. 
%        Let's verify its effect:
%        \begin{verbatim}
%            report (data)
%        \end{verbatim}
%
%    \item
%        We can also assign a particular cost to opening a gap block. Not
%        surprisingly the argument is \ phyg{gap\_opening}:
%        \begin{verbatim}
%            transform (tcm:(3,1), gap_opening:3)
%            report (data)
%        \end{verbatim}
%        Can you see the effect in the \ phyg{data} report? It is time now to
%        see the effect of the different parameters in the implied alignment.
%
%    \item
%        First read again your input data and build a tree:
%        \begin{verbatim}
%            wipe ()
%            read ("course.fasta")
%            build (1)
%        \end{verbatim}
%
%    \item 
%        Now we write down the cost of the tree, and output the implied alignment
%        in a file:
%        \begin{verbatim}
%            report (treestats, "1_2_ia.txt", implied_alignments)
%        \end{verbatim}
%
%    \item
%        Next we modify the cost regime to substitutions 1, indels 1, and report
%        the new cost as well as the implied alignment:
%        \begin{verbatim}
%            transform (tcm:(1,1))
%            report (treestats, "1_1_ia.txt", implied_alignments)
%        \end{verbatim}
%
%    \item
%        Finally we will do the same operations using a cost of 3 for
%        substitutions, 1 for an individual gap, and 3 for gap opening:
%        \begin{verbatim}
%            transform (tcm:(3,1), gap_opening:3)
%            report (treestats, "3_1_3_ia.txt", implied_alignments)
%            wipe ()
%        \end{verbatim}
%
%    \item
%        Compare the costs and the implied alignments. What do you expect? what
%        do you observe? Are the transformation cost matrices metric? Are your
%        characters metric? 
%
%    \item 
%        You can fix a particular scheme of indels using the command
%        \ phyg{transform (static\_approx)}, which stands for ``static
%        approximation''. A static approximation fixes a particular implied
%        alignment for the best tree in memory, and creates a set of characters
%        that match that particular alignment and resembles as much as possible
%        the cost regime of choice. Here is example of this:
%        \begin{verbatim}
%            read ("course.fasta")
%            build (1)
%            transform (tcm:(1,1))
%            report (data)
%        \end{verbatim}
%
%    \item 
%        We see that there are 8 molecular characters currently in memory.
%        Before we continue, as we will play around with this initial set of
%        characters and tree, we should store this initial state of the program:
%        \begin{verbatim}
%            store ("initial")
%        \end{verbatim}
%
%    \item
%        We can now check the implied alignment:
%        \begin{verbatim}
%            report (ia)
%        \end{verbatim}
%        Yes, \ phyg{ia} and \ phyg{implied\_alignment} are equivalent.
%
%    \item
%        This alignment can now be fixed to use the resulting matrix as the
%        characters:
%        \begin{verbatim}
%            transform (static_approx)
%            report (data)
%        \end{verbatim}
%
%    \item
%        Observe that after the transform there are no molecular characters left.
%        Instead, there are a number of non-additive characters.
%
%    \item
%        What happens if we have the default cost regime? Let's roll back to the
%        characters stored in ``initial'' and give this a try:
%        \begin{verbatim}
%            use ("initial")
%            transform (tcm:(1,2))
%            transform (static_approx)
%            report (data)
%        \end{verbatim}
%        What can you observe?
%
%    \item
%        Finally, let's check how the static approximation behaves if you have a
%        gap opening parameter:
%        \begin{verbatim}
%            use ("initial")
%            transform (tcm:(3,1), gap_opening:3)
%            transform (static_approx)
%            report (data)
%        \end{verbatim}
%        What is the main difference the you observe? How are indel blocks being
%        treated?
%
%    \item
%        Now we will learn how to \ phyg{transform} specific characters. Suppose
%        that we would like to assign \ phyg{tcm:(2,1)} to the first fragment in
%        course.fasta. We first check the name of the fragment:
%        \begin{verbatim}
%            use ("initial")
%            report (data)
%        \end{verbatim}
%        You can see that the name of the first fragment is \ phyg{course.fasta:0}
%        (the precise name may vary slightly in your computer). We can specify in
%        the transform command which characters should be transformed in which
%        way:
%        \begin{verbatim}
%            transform ((names:("couse.fasta:0"), tcm:(2,1)))
%        \end{verbatim}
%
%    \item
%        try to visually match the parenthesis and understand their effect. Here
%        is another example, aimed at up-weighting static homology characters
%        only:
%        \begin{verbatim}
%            transform ((static, weight:2))
%        \end{verbatim}
%        In this case instead of specifying characters by name, we do it by type.
%        This command probably makes the syntax easier to understand. If you had
%        troubles with the first one, try to understand the \ phyg{weight}
%        example and go back to the \ phyg{tcm:(2,1)} case again.
%
%    \item
%        To finish this section, we leave you a task: fix the alignment
%        of the third and fourth fragments of the file course.fasta
%        using cost 1 for substitutions and cost 1 for indels. Every
%        other character should have the default cost regime of
%        substitutions 1 and indels 2.
%\end{enumerate}


%\subsection{Perturbing trees for improved searches}
%
%\begin{enumerate}
%    \item Perturbing the search space is a powerful search strategy. The
%        fundamental concept is to modify the cost of the trees in such a way
%        that we can find even better trees from already good ones, that is, from
%        trees that are local optima. The \ phyg{perturb} command in phyg
%        implements this kind of search strategy.
%
%    \item \ phyg{perturb} works in the following way: for $n$ iterations, phyg
%        perturbs the characters using the arguments and options that we specify,
%        searches for optimal trees in the altered character landscape, and
%        finally searches the current best tree using the original characters.
%
%    \item The parsimony Ratchet is a classic powerful perturbation strategy in
%        phylogenetic research. In phyg, the \ phyg{ratchet} argument within the
%        \ phyg{perturb} command works by up-weighting a percentage of
%        characters. The default settings of \ phyg{perturb ()} performs a
%        ratchet in which 25\% of the characters are up-weighted by a factor of
%        2.
%
%    \item
%        Let us now perturb our data with the ratchet. First, we will read the
%        data, and the trees stored in the fuse tutorial, to perturb them:
%        \begin{verbatim}
%            read ("course.fasta", "fuse_course.tree")
%            perturb ()
%        \end{verbatim}
%
%    \item
%        How many iterations are performed by default? How many characters do you
%        have in your analysis?
%
%    \item
%        As you saw in the previous command, one problem we have is that the
%        ratchet works on characters, and this data set has few of them: only 8.
%        Our experience is that an excellent strategy is to apply the ratchet on
%        the characters produced by the implied alignment, that is, on the static
%        approximation.
%
%    \item To do this, we use the \ phyg{transform} command as an argument of
%        the \ phyg{perturb} command:
%        \begin{verbatim}
%            perturb (transform (static_approx))
%        \end{verbatim}
%        which executes the following algorithm:
%        \begin{itemize}
%            \item For $5$ iterations
%                \begin{itemize}
%                    \item Run the parsimony ratchet
%                    \item Transform back to the original dynamic homology
%                        characters
%                    \item Run a new search in the resulting tree
%                    \item If the new tree is better, replace the original.
%                \end{itemize}
%        \end{itemize}
%
%    \item
%        Now lets perform a ratchet with SPR and static approximation:
%        \begin{verbatim}
%            perturb (transform (static_approx), swap (spr))
%        \end{verbatim}
%
%    \item 
%        Alternatively, we can try to escape the local optima by perturbing the
%        cost of the matrix employed by the dynamic homology characters:
%        \begin{verbatim}
%            perturb (transform (tcm:(1,1)))
%        \end{verbatim}
%        Can you describe what this command does? An important observation is
%        that running five iterations of this command does not help at all. Can
%        you see why?
%
%\end{enumerate}
%
%\subsection{Using Search}
%
%\begin{enumerate}
%    \item The \ phyg{search} command runs a mixture of:
%        \begin{itemize}
%            \item Randomized wagner builds
%            \item TBR swapping
%            \item Nixon's ratchet
%            \item Exhaustive DO
%            \item Tree fusing
%        \end{itemize}
%
%    \item
%        \ phyg{search} should be the first analysis option for both new and
%        expert users. Let's start with a very small data set, so that we can get
%        some meaningful results with a very small amount of time:
%        \begin{verbatim}
%            wipe ()
%            read ("18s.fasta")
%            search (max_time:0:0:1) 
%            (* This will run a search for exactly 1 
%            minute *)
%        \end{verbatim}
%
%    \item
%        After this command finishes, you should see a message on screen telling
%        you how many trees where built, how many fusing generations where
%        performed, how many times the best tree was found, and what its score
%        is.
%
%    \item
%        We can constraint the search some more. Suppose that we
%        have, from previous searches, the impression that the best tree that we
%        could find has cost 385, hen we can tell phyg that this should be the
%        target cost for an expected number of hits:
%        \begin{verbatim}
%            wipe ()
%            read ("18s.fasta")
%            search (max_time:0:1:0, hits:5, target_cost:385)
%        \end{verbatim}
%        This command will now run for \emph{one hour} or until it has
%        found 5 trees with cost 385 or less, whichever happens first.
%
%    \item
%        If we have limited memory resources, we can now execute this search with
%        a memory constraint, so that phyg will only store as many trees as it can
%        fit in 256 MB or RAM, not more.
%        \begin{verbatim}
%            read ("18s.fasta")
%            search (max_time:0:1:0, hits:5, target_cost:385, 
%                memory:mb:256)
%        \end{verbatim}
%
%    \item 
%        So lets run a regular search for half an hour on the 18s data set, and
%        see what results you get. We will store the resulting trees in the file
%        18s.tree:
%        \begin{verbatim}
%            read ("18s.fasta")
%            search (max_time:0:0:30, memory:mb:256)
%            select ()
%            report ("search_18s.tree", trees)
%        \end{verbatim}
%
%\end{enumerate}
%
%\subsection{Calculating Supports: Jackknife}
%This method calculates Jackknife support values for input graphs. This method specifies
%that resampling is performed with $n$ acceptance probability (default 0.6231 or $1 - e^{-1}$). 
%
%\begin{enumerate}
% 
% \item Using your text editor of choice, make a new script to generate the 
% Goodman-Bremer  support values for our newick tree from \textbf{run1.pg}.
% 
%         \begin{quote}
%	-\/-Jackknifes for chel\_run1\\
%	set(seed:73412305) \\
%	set(outgroup:"Limulus") \\
%	read(nucleotide:"chel\_16S.fas") \\
%	read(nucleotide:"chel\_cox1.fas") \\
%	read(newick:"chel\_run1.tre") \\
%	support(jackknife:1000)\\
%	report("chel\_run1\_jk.dot", support, dotpdf, overwrite)
%        \end{quote}  
%       
%\item Save this file in the same directory as your tree file, i.e. \texttt{run1}.
%We will name this file \texttt{run1\_JKs.pg}.
%
%\item Execute the script:
%
%	\begin{quote}
%  	phyg run1\_JKs.pg
%	\end{quote}
%	
%\item Examine the reported files. Jackknife values, represented as jackkife
%frequencies are labelled over the branches.

%\begin{enumerate}
%  
%  \item 
%        The command \ phyg{calculate\_support (jackknife)} performs n pseudoreplicates independently, in each once a percentage of characters in selected at random, without replacement.  The frequency of occurrence of a clade is its jackknife support value.
%        
%        \item 
%      Open the program documentation (in the help menu of the Graphic User Interface Window).  Go to the command reference chapter and find the \ phyg{calculate\_support} command.  Find the jackknife argument, and read its description and default values, and how to specify the number of pseudoreplicates inside calculate\_support. Then write a command to do just 50 pseudorplicates, using the default values of jackknife.
%      
%       \item 
%      An important detail is that jackknife resamples the characters.  What you define as a characters is a biological question that you must resolve before running your analyses.  phyg does not calculate jackknife supports in any special way, it is just the case that the characters that you are using are not necessarily just the bases of your sequences, but the sequences themselves!
%      
%       \item 
%      A common procedure used by many biologists is to fix an alignment and compute support values resampling the bases of that alignment.  Let us use this strategy and compare the support values for a pair of different alignments on the same tree.  To do this we will use a new report argument:
%      
%       \begin{verbatim}
%        read ("course.fasta")
%        transform (tcm:(1,1))
%        store ("initial")
%        search (max_time:0:0:1)
%        select ()
%        \end{verbatim}
%
%    \item We store the tree in a file so that then we 
%            can report support values for it:
%
%    \begin{verbatim}
%        report ("tree_for_support_values.tre", trees)
%        transform (static_approx)
%        report ("good_alignment.ss", phastwinclad)
%        (* This commands output a NONA file that can 
%        be read in many programs, most notably phyg *)
%    \end{verbatim}
%      
%\item Now we will produce a different alignment and store it 
%\begin{verbatim}
%        use ("initial")
%        build (1)
%        transform (static_approx)
%        report ("regular_alignment.ss", phastwinclad)
%        \end{verbatim}      
%
%    \item
%           We have just produced our two data sets that 
%           we will use to calculate supports.  The second 
%           data set is currently held in memory.
%\begin{verbatim}
%       calculate_support (jackknife: (resample:1000))
%       read ("tree_for_support_values.tre")
%       calculate_support (jackknife: (resample:1000))
%       read ("tree_for_support_values.tre")
%       (*We just stored the tree in a file to 
%       compare the results later *)
%        \end{verbatim} 
%           
%        \item Now we will compute the support values 
%            using the first alignment
%\begin{verbatim} 
%    wipe ()
%    read ("good_alignment.ss")
%    calculate_support (jackknife: (resample:1000)
%    read ("tree_for_support_values.tre")
%    report ("good_alignment_supports.ps", 
%        graphsupports:jackknife)
%    \end{verbatim}     
%        
%        Compare the two trees (using an image edition program, nothing special
%        is needed for Mac OS X, Linux, or Unix, but Windows computers may 
%        need Ghostview or Adobe Illustrator):
%        \begin{itemize}
%            \item good\_alignment\_supports.ps.
%            \item regular\_alignment\_supports.ps.
%        \end{itemize}
%        What did you notice? Where do you get better supports? Which would be a reasonable alignment from which to compute your support values? 
%         
%         \item 
%         To calculate bootstrap support values, find the  \ phyg{bootstrap} argument in the \ phyg{calculate\_support} command documentation, and repeat the previous (Calculating Supports: Jackknife) excercise using good\_alignment.ss and regular\_alignment.ss files to generate bootstrap supports for the tree in tree\_for\_support\_values.tre, in eactly the same way.
%       
%          \end{enumerate}
%
\subsection{Calculating Supports: Goodman-Bremer}

This method calculates Goodman-Bremer support values for input graphs. The 
method traverses the SPR or TBR neighborhood, to determine an upper bound 
on the NP-hard values. The arguments of \texttt{goodmanbremer} (\texttt{spr} or 
\texttt{tbr}) are optional, but \phyg will, by default, traverse the TBR neighborhood. 
The command \texttt{report(support)} labels the edges with bootstrap frequencies.

\begin{enumerate}
 
 \item Using your text editor of choice, make a new script to generate the 
 Goodman-Bremer  support values for our newick tree from \textbf{run1.pg}.
 
         \begin{quote}
	-\/-Goodman-Bremers for chel\_run1\\
	set(seed:73412305) \\
	set(outgroup:"Limulus") \\
	read(nucleotide:"chel\_16S.fas") \\
	read(nucleotide:"chel\_cox1.fas") \\
	read(newick:"chel\_run1.tre") \\
	support(gb:spr, gbsample:10000)\\
	report("chel\_run1\_gb.dot", support, dotpdf, overwrite)
        \end{quote}  
       
\item Save this file in the same directory as your tree file, i.e. \texttt{run1}.
We will name this file \texttt{run1\_GBs.pg}.

\item Execute the script:

	\begin{quote}
  	phyg run1\_GBs.pg
	\end{quote}
	
\item Examine the reported files. Goodman-Bremer values are present
over the branches.
%       One way to do a search for Bremer supports is to constrain the search so that a particular clade is never allowed in the tree that is being visited.  This is exactly what \ phyg{calculate\_supports (bremer)} does.
%       To test this command, first read the best tree that you could find from all the searches (e.g. after fusing and ratcheting). We will first generate a good tree for the bremer supports:
%        Notice that this command is slow, as it performs a very intense search.  Ten trees are built and swapped on each branch.  If your original search was not powerful enough, this command may find shorter trees than your initial search. 
%        When this command is finished, we are ready to report the support values for this tree.
%        \begin{verbatim} 
%         	   report (supports:bremer)
%        \end{verbatim}  
%          
%          Another way to calculate Bremer supports is to not constrain the search at all, and from the trees visited, collect the information for the clades not present.  To do this we can use the \ phyg{visited} argument within swap.
%          
%          \begin{verbatim} 
%            build (100)    
%            swap (cisited:"for_bremer.txt")
%            select (best:1)
%            read ("tree_for_bremer.tre")
%            report (supports:bremer:"for_bremer.txt")
%                   \end{verbatim}  
%
%This strategy has several advantages.  First and foremost, it tends to yield tighter support values (lower).  Secondly, it is more efficient in the sense that the default technique has to repeat the search for every clade to collect the necessary information, while this strategy collects all the clades from the same strategy.  Finally, you can calculate Bremer support with your search strategy of choice.  You may cancel this Bremer search at any time and the necessary information will remain stored in the file and the best tree found in your overall search, which means that you will never recover negative Bremer support values. 
%          
\end{enumerate}
%\printindex

\end{document}
