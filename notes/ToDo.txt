 1) add tnt fasta/c tcm stuff and -? to docs
	Source docs
	User docs

2) Create MatrixApproxSmall, MatrixApproxLarge
	Prealigned chars
	Add to test.pg

3) Reexamine "executeCommands" to make more stream like
	passing various results back to itself till all done
	THis allow builds, swaps, transformtion in order
	E.g. search tree first then network, search non implied alignment

4) Set graph complexity for hard-wired ans soft-wired graphs differnetly
	Hard-wired--as in complexity code now--just edges and vertices
	Soft-wired--account for the display tree set
		extra edges?, "switching" cost among diaplay trees? log2 2^n?
		so regular graph + n bits? or somehting related to grahs specification
		etc so miuch larger--toal complexity of entire dispolay tree set.
		Can be generated in code so see what it is?  To add recursive generation
		of display trees. YThat is prob the way to do it. And also add in swtitch 
		tree cost (log2 2^n)  

5) Set blocks

6) Transform 
	Matrix <-> ApproxMatrix

7) Newick--count bits in bitvector of nodes to deermine laeft versus right
  so output smaller group "top" left and "right" bottom.
  If equal  "Lower" number value left (ie earlier in input list)
  likley more basal groups earlier in matrix

8) select command for taxa/chars/blocks
	to only use a list of taxa

9) Consolidate General sequence characters in the same block with the same
	TCM.  Would have to merge alphabets and TCMs so that only need a single 
	hashMap for them 
	Would need to modify the CharacterData type to add a Vector (Vector BV.BV)
	to hold teh multiple sequenxe states like with static characters.
	Same for Matrix/Sankoff

10) General sequence characters--thread hashMap through traversal--or any tree cost determination
	Need to return it with tree to update CharInfo to incude updated hashMap
	Would need to add to the CharacterData type to hold hashMap, 
	empty in leaves so use the initial charInfo hashMap, then take childrens HashMaps, 
	if they are unequal in length, union them, and update through DO
	returning updated hashMap at end with cost to potentially (if length increases) 
	update the charInfo hashMap field
	THis would be obviated with Alex and Callan's code if it can be migrated in.
	But basically--anyhting that returns a tree will have to return potentially updated
	CharInfo wrt hashMap


13) For pre-order 
	input left and right Vectors of vectors--one will have length 1 (parent), the other length
	2 (two children). Align/DO on that basis 

	Will need to keep gapped results from post-order to do properly
	if keep left/right gap info can create IA efficently ala Alex algorithm

	rely on lazyness to be effecient if don't need IA 

16) Time concistencuy test for graphs (input especially)

17) Set for "gobal" values--would have tyo be passed around as well 
	Part of processed data?

18) Check all commands before execution for valid syntax
	so don't error out at very end after lots of effort

21) Profile info +RTS -xc -RTS after cabal build --allow-newer --enable profiling
	bin +RTS -p -RTS args....
	creates prog.prof

24) fix tcmMemo
	Unpredictable behavior not found in non hash memo version
	Could be unsafeIO isssue in FFI of hashmap?

25) Special case tcmMemo sub/inDel?
	need to check tcmMemo  very slow for sub/indel only
	ensure its actually updating and not recreating every time

31) Modify charInfo to have gapped, left gapped, right gapped triple

32) Add affine cost option
	modify charInfo field for affine cost
	first arg in generateDenseTransitionCostMatrix
	0 /= 0

33) Test ladderize
	look may fail if indegree 1 outdegree 1 vertex

34) Test graph -> tree

35) test contract edges in input
	a-x-b -> a-b

36) test time consistancy
	non overlap of "before" and "after" nodes
	for each network node 
	Consistency among
	Before nodes
	After nodes 
	Equal nodes and their before and after

37) new network edges
	No ancestral edges	
	No descendant edges
	No ancestors of network ancestor sister 
	No descendants of network descendant sister

41) For output diagnosis
	rediagnose graph(s) wiht Naive data for more legible output

42) Add function to map bitvector back to alphabet states (including ambiguities)

43) Add edge transformations for diagnosis output

44) expand read for wildcards
	issue wirth modifier--needs to be propagated--ie "fasta"

46) need to remove blank lines from newick nbefore parse

47)  Output alphabets incorrect;ly formated--should be single string, same for TCM

48) Hartigan 1973 preorder optimization

49) additive to binary for small number states?  Bit packing

50) Bit packing 
	Ronquist 1998, Goloboff 1999, 2002, Moelannen 1999, White and Holland 2011.

51) Additive chars recoded to binary (and packed)

52) Node clusters--Goloboff 1996,1999

53) tree comparison hash, 
	Could be hash of edges wth min 0 filtered out

54) Add parallel over blocks and characters in blocks

55) TNT -, ? parse with TNT command?

57) Add sum line and column to crossrefernces

58) reverse cross ref loci ?

62) Change dynamic (non-exact) type to single "character" not vector
	since each nonexact character needs to be multi-traversed

69) Every tree node is an inflexion point in graph
	for SPR/TBR/TF

70) Add Alex binary tree rendering for ascii output

71) latex structure and all that stuff on how it works + haddock functions

72) stylish and hlint source code

81) Filter data for isPrint ?

82) Prune taxa from graphs (in fgl) based on taxa included

83) Parallelize data processing

85) Name glob other input file names--rename files etc

86) Fix alphabet outout in diagnose to be single column

81) Check all command execution for correctness before execution.
	except perhaps filenames
		commands and options 
	
82) Need to add prealigned charcater/DO like
	recode to matrix?  Approx matrix?

83) Ensure 1:1 and 1:n are dfauilting to bit operations in DOs
	Taking a very long time 

84) Fix diag output wrt sequences (IUPAC ambiguities for DNA)
	had to replace Alex code in report do to empty list issues

85) Check reroot best greaph stuff with exact characters

87) Test matrix characters optimization and costs

88) add logic instead of multiplication for weight factor in graph cost

89) Add tests--integration most likely
	What systems?

90) Change partition names/character names for cross-references output

91) Text reorganiztion with matrix characters wiht different matrices

92) add functinoality (basicaly for missing data) for multiple non-exact characters
	
	This will be nnecessary with "block" set issues or can be delayed iuntil block manupulations are implemented

	in a single block--eg linguistic, autosomal
	The current issue is that when using lists (from Vectors) missing seqeunce characters are stored as [].
	This causes problems adding lists togething when extracting the "column" of teh charater that would be 
	prepended (and later reversed) to the next sequence charcater in that block etc.  One posible soluiotn might be to 
	del with them as vectors.  Also cons and snoc are less efficient--but still likeli have the issue of 
	V.empty for missin and consing two of them still gets you a singel V.empty--and similar problems with
	taxa that have a mix of observed and missing characters.  Perhpas change type of missing from [] to "missing charcater"
	Character record type or Maybe Character, or a field in Character, or tuples or somehting.  Should not
	be a problem for exact charcaters since there is an explicit value for missing for add/non-add/matrix

95)  Pre-order make sure there is a tree for each charecta and excat same root as Decorated graph


96) set vertex info with union of vertices for later heuristics?
	Would have to have somehting akin to vertData (VertexBlockData = V.Vector (V.Vector CharacterData)) 
	and access to CharInfo--all in phylogenetic graph
	But might be a problem with rearrangements, with edges and vertices coming and going.  Maybe not.

97) Whidden eta l 2009 2010 for fast SPR tre distance FPT

98) Tree rendering
	Alex's code
	https://hackage.haskell.org/package/tree-render-text-0.4.0.0/docs/Data-Tree-Render-Text.html
		Based on Data.Tree
		
		import Data.Tree
			import Data.Tree.Render.Text

			tree :: Tree String
			tree
			  = Node "Add"
			    [ Node "Add"
			      [ Node "0" []
			      , Node "Mul"
			        [ Node "1" []
			        , Node "2" []
			        ]
			      ]
			    , Node "Neg"
			      [ Node "Max"
			        [ Node "3" []
			        , Node "4" []
			        , Node "5" []
			        , Node "Var"
			          [ Node "x" []
			          ]
			        , Node "6" []
			        ]
			      ]
			    ]

https://hackage.haskell.org/package/tree-view-0.5.1/docs/Data-Tree-View.html
https://hackage.haskell.org/package/diagrams-contrib-0.1.0.0/docs/Diagrams-TwoD-Layout-Tree.html

Write LGGraph -> Data.Tree and use 	https://hackage.haskell.org/package/tree-render-text-0.4.0.0/docs/Data-Tree-Render-Text.html
to render--would have repeated subtrees after network vertex

99) Error in tree length for distance trees
	caused likely by flipVertices and/or dichotomizeRoot
	Check by looking at ouput dot format

100)  Randomize list of additions--ST monad and return pure?

101) Dashes in tnt files--option?
	Document

102 ) partitioned data in blocks fix for traversal multiple sequence
	Taran data

103) Pre-order
	Feilds are in order of (median, left, right)
	Symbol count is length of alphabet (toEnum $ length alphabet)
	isLeft (as in is leftChild really leftChild)
		-- either modify postorder 
		-- or be consistemt on left/right children as in DOMedian left right
			use Bitvector of vertex


104) label invariven data has-> bv label

105) Only partition DNA/Amino Acid data

106) filter fasrtcv raw data C.isPrint--aftert fix median huge issue

107) Graphical profiling

	profiteur phyg.prof (from +RTS -p after --enable-profiling)
	xdg-open phyg.prof.html

	^C only 1 time to get prof info if not complete

108) read distance?
	name, data issues etc.
	if null data could just return distance costs

113) IA  branche info for all collepsing branchlengths etc

114)  Add block PhylogenticGraph for rees as same as Decorated Graph

115) Check dependence of tree root on num OTUs
		forest obviously no

116) refactor command checking code at begining of commands 

117) refactor median2,noneexact, M2Single/nonexact
	add arg for nonexactg stuff

118) Clean up warnings

119) in make median--for final as well--need to check that nought
	for parents not child (check paper)

121) Verify unique tree output for same length

122) get branch lenghths on preorder pass for collapsing later
	also--perhaps edge vertex states?

123) add single assignment and singal assignment edge weights
	Can be added later if needed for outpu display or lengths
	or could use average of min and max as a placeholder for now

124) Test tree length on small huge alphabet tree

125) For checking indexing after preorder--
	print children and parent node indices to make sure still same

127) root "first" taxon--first after reordering
	so based on lexical sorting.  IS this ok?

129) Prealigned to nonadd/matrix

130) Return Bridge set 
	GraphAlgorithmBook.pdf
	https://www.geeksforgeeks.org/bridge-in-a-graph/


142) At some point keep equally costly traversals so
        add another vector dimension to  traversal trees in Phylogenetic graph

142) For soft-wired
        1) change block graph tuple to Vector of Vector of Decorated graphs to hold
                        multiple (equally costly) display trees for a given block
                        when have block sets can reduce by intersection of display trees
                        for each block could reduce complexity of output a great deal


        2) Add resolution set to vertex information
                Only updated in softwired graph optimization
                Trees and Hardwired can be empty
                        [VertData] ?
                        Child indices?
                        keep trees on post order for diaply tree later


143) Check optimization for input forest
	issues with rootindex
	need to make more flexible so can just map over components
	perhaps splitgraph/merge graph type thing to keep root index as nOTUs
	perhaps remove to an added option to break on "long" edges at with
	separate functions

144) Check optimization for multirooted components

145) rationalike tree/graph, softwired, hardwired traversal function names

146) Bridge Tarjan
	Popcount for size subtree

147) time consistency
	list of all edges
		\\ network edges
		\\ ancestor edges
		\\ descdendant edges
		\\ opposite side of anc or desc network edge
				(synchonization event)

148) Block build network initial build
	trees from block (remove missing from distance or whatever)
		rooting on common leaf
	combine via EUN/CUN
	reroot on outgroup
	label/filter unused edges


150) Question on node and edge data in display tree filed of resolution data
  How much in there? is actually needed for preorder etc.


151) Display trees created in post order of softwired will have to have root vertex and edge moved
	-- enunmerated as created

152) Outgroup edge as source for network edge--probbaly not.

153) Report display trees by block

154) reduce number of resolutions by checking if charctert assignments 
	(Vector character data) and displayBV data are equal
	could have different display trees--would loose that info, but could speed up alot.
	Make an option in global settings?  Would have same leaf set (bvlabel) but different edges.

155) Document compress resolutions

156) In=out=1 contract for newick output

157) Change Recsolution Block data to Vector
	For traceback and resolution compression efficiency


158) resolution vector stuff has alot of list <-> vector intercoversions
	Prob could be cleaned up a faitr amount

159) Better--simpler Graph format for display trees
	Can do conversions for traceback etc
	Right now its a bogus DecoratedGraph

160) Split tree, soft-wired, functtions.  
	Make common traversal functions separate file (ie pre-order stuff)

	
161) Incremental pot-order traceback for soft-wired
	during rerooting


162) remove Maybe from resoltion child type

166) make forest a final set deleting edges?

172) After fix in DO, make IA and DO final states and branch lengths

173) rename reroot functions to make more sense

174) Abstract rectify graph functions
	Maybe a tuple with two kinds of graphs and branch WRT node update

175) Move softwired traceback to preorder ?

176) Refactor and separate tree and softwired stuff
	Use old reroot tree functions for tree--stuff is screwed up now for tree

177) remove calls to getRoots  must be O(n)

178) Add graph reconciliation functions and report 

179) Add no error dot-pdf output

180) Check size of (number of) resolutions, that its not blowing up

181) add root cost stuff

182) test net/root penalty 

183) Fix fenewick for degenerate (no edges) tree
	Convert to forest then fmap

184) sort edges for swap 
	by length (perhaps better for net edges)
	by closness to deleted edge (good for swpping smaller edits first)
	
185) verify ladderize graph both in and out > 1, > 2

186) Graph distance matrix output RF, SPR, TBR, net+SPR/TBR

187) create incremental postorder pass for use in wagern and swapping
	add damping if possible

188) write multiTraverseFullyLabel for softWired and tree 
	but for a single component
	passing in leafGraph and component root
	leave no overall root component untouched


191) Should slim final be a triple?  Save on conversion back and forth perhps

194) Alex Data.Alphabet usefule funciotns for coding and uncoding functions
	
195) Hadock

196) prelim/fimal states rendered using alphabet library

197) replace made un gapped medians--eith extract median
	
	runST to get mnutlkable out of 'm'

200) Tasty and quickcheck for tests

204) Add parlist chunk finctionality for wagner and EUN
	https://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel-Strategies.html

207) Incremental optimization with delta for cost at root--need to update other node costs
	past convergance?  Prob yes

208) NNI/SPR/TBR with netwprks directly (invade all edges subject to coeval constaints)


209) refactor postorder to be separate functions

210) preorder to deal with multiple roots

211) Swap preorder on base graph, add back nodes from pruned on original, then preorder

212) rerrot tree make morefficient--rewrite

213) musl for static binaries

214) Check median left right order for static charcaters--make sure same as dynamic
	And for IA assignments as well

216) static branch lengths wrong

217) check swap delta cost for matrix charcaters

218) Use postorder for cost--then preorder after

219) remove all the parent child stuff from vertex--never used, rely on grpah functions

220) Migrate outputs to alphabet functions for ambiguity

221) Outputs with char changes in positions apolist type

222) abstract steepest and all functions to simplify code

223) Is sorting edges oni length ofr steepest effective?

225) option to not do branch lengths--don't need in SPR/TBR

226) SPR root state -- should be union of two descendants

227) Modify chunk parallel like seqParMap if thread==1 do nothing

231) chnge delta calcualtion--to edge calculateoin wag style--missing good graphs

232) rediagnose preorder pass if chnage final assignment

233) Check through <= delta in swap and wagner build

234) create alternate spr-tbr for when find new in steepest

235) check edges for splitting and readding--make sure not missing some edges--especially near root

236) Check order or branche readdition confirm sequence in closest order

237) Check BV graph equality--including zero-length edges

238) add set seed command
	for replicability of randomized searches

239) IA swapping for network--perhoaps not due to non-uniquwe aspwect of resolutions

240)  Need to devfelop some shorcut for network stuff--all full traversals now
