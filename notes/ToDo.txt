1) add tnt fasta/c tcm stuff and -? to docs
	Source docs
	User docs

2) Create MatrixApproxSmall, MatrixApproxLarge
	Prealigned chars
	Add to test.pg

3) Reexamine "executeCommands" to make more stream like
	passing various results back to itself till all done
	THis allow builds, swaps, transformtion in order
	E.g. search tree first then network, search non implied alignment

4) Set graph complexity for hard-wired ans soft-wired graphs differnetly
	Hard-wired--as in complexity code now--just edges and vertices
	Soft-wired--account for the display tree set
		extra edges?, "switching" cost among diaplay trees? log2 2^n?
		so regular graph + n bits? or somehting related to grahs specification
		etc so miuch larger--toal complexity of entire dispolay tree set.
		Can be generated in code so see what it is?  To add recursive generation
		of display trees. YThat is prob the way to do it. And also add in swtitch 
		tree cost (log2 2^n)  

5) Set blocks

6) Transform 
	Matrix <-> ApproxMatrix

7) Newick--count bits in bitvector of nodes to deermine laeft versus right
  so output smaller group "top" left and "right" bottom.
  If equal  "Lower" number value left (ie earlier in input list)
  likley more basal groups earlier in matrix

8) select command for taxa/chars/blocks
	to only use a list of taxa

9) Consolidate General sequence characters in the same block with the same
	TCM.  Would have to merge alphabets and TCMs so that only need a single 
	hashMap for them 
	Would need to modify the CharacterData type to add a Vector (Vector BV.BV)
	to hold teh multiple sequenxe states like with static characters.
	Same for Matrix/Sankoff

10) General sequence characters--thread hashMap through traversal--or any tree cost determination
	Need to return it with tree to update CharInfo to incude updated hashMap
	Would need to add to the CharacterData type to hold hashMap, 
	empty in leaves so use the initial charInfo hashMap, then take childrens HashMaps, 
	if they are unequal in length, union them, and update through DO
	returning updated hashMap at end with cost to potentially (if length increases) 
	update the charInfo hashMap field
	THis would be obviated with Alex and Callan's code if it can be migrated in.
	But basically--anyhting that returns a tree will have to return potentially updated
	CharInfo wrt hashMap

12) Modify DO functions to return additional fields
	For post order, return postorder median2D, "gapped" median2D, "gapped" left and right children
	For preorder:
		Do DO pairwise based on "gqpped" preliminary state, BUT
		traceback based on "gapped" children (same length as gapped preliminary)
		Can apply tcmDense3 (or hashMap for general seqeunces) on traceback to
		parent, gapped children during traceback to get "final" assignment 

		traceback produce a list of 3-tuples gapped children and preliminary,
		filter gaps out of preliinary for that field (keep gapped too),
		Convert to Vector so cheaper cons

		Maybe try to remove the Vector "cons" and make it work on lists
		to have O(1) prepend only previous row has index access--and that is n ot random
		but only one previous so probbaly could be done as a list 
		Perhaps better with Data.Sequence, constant time pre/append
		random access min (i, n-i) so OK for first r seond element--
		still should deal with head tail of previous row for contant access,
		and input data wold have to be vector because they are somehwt random,
		but that cold be worked around as well if need be.

		So could use Data.Sequence for interna NW matrix, but vectors for seqeunces--basically 
		avoiding all teh O(n) cons-ing

		Would have to write own unZip4 but that's not so bad

13) For pre-order 
	input left and right Vectors of vectors--one will have length 1 (parent), the other length
	2 (two children). Align/DO on that basis 

	Will need to keep gapped results from post-order to do properly
	if keep left/right gap info can create IA efficently ala Alex algorithm

	rely on lazyness to be effecient if don't need IA 

16) Time concistencuy test for graphs (input especially)

17) Set for "gobal" values--would have tyo be passed around as well 
	Part of processed data?

18) Check all commands before execution for valid syntax
	so don't error out at very end after lots of effort

21) Profile info +RTS -xc -RTS after cabal build --allow-newer --enable profiling
	bin +RTS -p -RTS args....
	creates prog.prof

24) fix tcmMemo
	Unpredictable behavior not found in non hash memo version
	Could be unsafeIO isssue in FFI of hashmap?

25) Special case tcmMemo sub/inDel?
	need to check tcmMemo  very slow for sub/indel only
	ensure its actually updating and not recreating every time

26) Special case costonly for C-FFI
	New wrapper for C-FFI with alternate input output types
	Triple of vectors as opposed to vector (NE) of triples 
	Will want to do this to make traversals etc more 
	maintainable

	For now profile the conversion functions to see how
	much time suck they are (prob little)

27) Check if DO swap is necessary maybe done by ffi
	Not necessary for large-Naive DO.

30) Fix small (?) error in UkkonenDO for BitVector and Int64
	for possibility of long large alphabet sequences
		Check 1:1 versus 1:2 first

31) Modify charInfo to have gapped, left gapped, right gapped triple

32) Add affine cost option
	modify charInfo field for affine cost
	first arg in generateDenseTransitionCostMatrix
	0 /= 0

33) Test ladderize
	look may fail if indegree 1 outdegree 1 vertex

34) Test graph -> tree

35) test contract edges

36) test time consistancy
	non overlap of "before" and "after" nodes
	for each network node 
	Consistency among
	Before nodes
	After nodes 
	Equal nodes and their before and after

37) new network edges
	No ancestral edges	
	No descendant edges
	No ancestors of network ancestor sister 
	No descendants of network descendant sister

39) add smart reroot to traversal
	and only for dynamic characters
	do regular traversal first
		then reroot from that, bt only apply to dynamic
		keep foci for preorder

40) Do preorder with traversal foci

41) For output diagnosis
	rediagnose graph(s) wiht Naive data for more legible output

42) Add function to map bitvector back to alphabet states (including ambiguities)

43) Add edge transformations for diagnosis output

44) expand read for wildcards
	issue wirth modifier--needs to be propagated--ie "fasta"


45) Tree lengths seem way off for primate data--maybe multiple counting?
	One block bleeding into another?  Doesn't seem to affect doubling of data file

46) need to remove blank lines from newick nbefore parse

47)  Output alphabets incorrect;ly formated--should be single string, same for TCM

48) Hartigan 1973 preorder optimization

49) additive to binary for small number states?  Bit packing

50) Bit packing 
Ronquist 1998, Goloboff 1999, 2002, Moelannen 1999, White and Holland 2011.

51) Additive chars recoded to binary (and packed)

52) Node clusters--Goloboff 1996,1999

53) tree cmoparsino hash, 
	Could be hash of edges wth min 0 filtered out

54) Add parallel over blocks and characters in blocks

55) TNT -, ? parse with TNT command?

56) add back reroot
